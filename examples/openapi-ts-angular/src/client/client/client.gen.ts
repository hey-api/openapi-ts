// This file is auto-generated by @hey-api/openapi-ts

import type { HttpResponse } from '@angular/common/http';
import { HttpClient, HttpEventType, HttpRequest } from '@angular/common/http';
import {
  assertInInjectionContext,
  inject,
  provideAppInitializer,
} from '@angular/core';
import { firstValueFrom } from 'rxjs';
import { filter } from 'rxjs/operators';

import type { Client, Config, ResolvedRequestOptions } from './types.gen';
import {
  buildUrl,
  createConfig,
  createInterceptors,
  mergeConfigs,
  mergeHeaders,
  setAuthParams,
} from './utils.gen';

export function provideHeyApiClient(client: Client) {
  return provideAppInitializer(() => {
    const httpClient = inject(HttpClient);
    client.setConfig({ httpClient });
  });
}

export const createClient = (config: Config = {}): Client => {
  let _config = mergeConfigs(createConfig(), config);

  const getConfig = (): Config => ({ ..._config });

  const setConfig = (config: Config): Config => {
    _config = mergeConfigs(_config, config);
    return getConfig();
  };

  const interceptors = createInterceptors<
    HttpRequest<unknown>,
    HttpResponse<unknown>,
    unknown,
    ResolvedRequestOptions
  >();

  const request: Client['request'] = async (options) => {
    const opts = {
      ..._config,
      ...options,
      headers: mergeHeaders(_config.headers, options.headers),
      httpClient: options.httpClient ?? _config.httpClient,
      serializedBody: undefined,
    };

    if (!opts.httpClient) {
      assertInInjectionContext(request);
      opts.httpClient = inject(HttpClient);
    }

    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security,
      });
    }

    if (opts.requestValidator) {
      await opts.requestValidator(opts);
    }

    if (opts.body && opts.bodySerializer) {
      opts.serializedBody = opts.bodySerializer(opts.body);
    }

    // remove Content-Type header if body is empty to avoid sending invalid requests
    if (opts.serializedBody === undefined || opts.serializedBody === '') {
      opts.headers.delete('Content-Type');
    }

    const url = buildUrl(opts);

    let req = new HttpRequest<unknown>(opts.method, url, {
      redirect: 'follow',
      ...opts,
      body: opts.serializedBody,
    });

    for (const fn of interceptors.request._fns) {
      if (fn) {
        req = await fn(req, opts);
      }
    }

    let response;
    const result = {
      request: req,
      response,
    };

    try {
      response = await firstValueFrom(
        opts.httpClient
          .request(req)
          .pipe(filter((event) => event.type === HttpEventType.Response)),
      );

      for (const fn of interceptors.response._fns) {
        if (fn) {
          response = await fn(response, req, opts);
        }
      }

      let bodyResponse = response.body as Record<string, unknown>;

      if (opts.responseValidator) {
        await opts.responseValidator(bodyResponse);
      }

      if (opts.responseTransformer) {
        bodyResponse = (await opts.responseTransformer(bodyResponse)) as Record<
          string,
          unknown
        >;
      }

      return (
        opts.responseStyle === 'data'
          ? bodyResponse
          : { data: bodyResponse, ...result }
      ) as any;
    } catch (error) {
      for (const fn of interceptors.error._fns) {
        if (fn) {
          (await fn(error, response!, req, opts)) as string;
        }
      }

      return opts.responseStyle === 'data'
        ? undefined
        : {
            error,
            ...result,
          };
    }
  };

  return {
    buildUrl,
    connect: (options) => request({ ...options, method: 'CONNECT' }),
    delete: (options) => request({ ...options, method: 'DELETE' }),
    get: (options) => request({ ...options, method: 'GET' }),
    getConfig,
    head: (options) => request({ ...options, method: 'HEAD' }),
    interceptors,
    options: (options) => request({ ...options, method: 'OPTIONS' }),
    patch: (options) => request({ ...options, method: 'PATCH' }),
    post: (options) => request({ ...options, method: 'POST' }),
    put: (options) => request({ ...options, method: 'PUT' }),
    request,
    setConfig,
    trace: (options) => request({ ...options, method: 'TRACE' }),
  };
};
