import type { IR } from '~/ir/types';
import { buildName } from '~/openApi/shared/utils/name';
import {
  createOperationComment,
  hasOperationSse,
  isOperationOptionsRequired,
} from '~/plugins/shared/utils/operation';
import type { TsDsl } from '~/ts-dsl';
import { $ } from '~/ts-dsl';

import type { SwrPlugin } from '../types';
import { useTypeData } from '../useType';
import { registerSwrKey } from './swrKey';

const optionsParamName = 'options';

/**
 * Create useSWR options for a given operation.
 *
 * This generates a function that returns an object with:
 * - key: The SWR key (always returns a valid key array, never null)
 * - fetcher: Async function that calls the SDK function
 *
 * The key is generated by the registered swrKey function, which follows these patterns:
 * - No params: ['/api/users']
 * - Required params: ['/api/users/{id}', options.path.id]
 * - Optional params: ['/api/users', options?.query] (uses optional chaining)
 *
 * Note: Conditional fetching should be controlled by the consumer:
 * useSWR(condition ? getUserOptions() : null, fetcher)
 *
 * Example outputs:
 * // Required parameters
 * export const getUserByIdOptions = (options: GetUserByIdOptions) => ({
 *   key: getUserByIdKey(options),
 *   fetcher: async () => {
 *     const { data } = await getUserById({ ...options, throwOnError: true });
 *     return data;
 *   },
 * });
 *
 * // Optional parameters
 * export const getInventoryOptions = (options?: GetInventoryOptions) => ({
 *   key: getInventoryKey(options),
 *   fetcher: async () => {
 *     const { data } = await getInventory({ ...options, throwOnError: true });
 *     return data;
 *   },
 * });
 */
export const createSwrOptions = ({
  operation,
  plugin,
  queryFn,
}: {
  operation: IR.OperationObject;
  plugin: SwrPlugin['Instance'];
  queryFn: ReturnType<typeof $.expr | typeof $.call | typeof $.attr>;
}): void => {
  if (hasOperationSse({ operation })) {
    return;
  }

  const isRequiredOptions = isOperationOptionsRequired({
    context: plugin.context,
    operation,
  });

  // Register SWR key first
  const symbolSwrKey = registerSwrKey({ operation, plugin });

  const typeData = useTypeData({ operation, plugin });

  // Check if operation has parameters
  const hasParams =
    (operation.parameters?.path &&
      Object.keys(operation.parameters.path).length > 0) ||
    (operation.parameters?.query &&
      Object.keys(operation.parameters.query).length > 0);

  // Create the SDK function call
  const awaitSdkFn = $(queryFn)
    .call(
      $.object().spread(optionsParamName).prop('throwOnError', $.literal(true)),
    )
    .await();

  const statements: Array<TsDsl<any>> = [];

  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {
    statements.push($.return(awaitSdkFn));
  } else {
    statements.push(
      $.const().object('data').assign(awaitSdkFn),
      $.return('data'),
    );
  }

  // Build the key call - only pass options if operation has parameters
  const keyCall = hasParams
    ? $(symbolSwrKey).call(optionsParamName)
    : $(symbolSwrKey).call();

  // Build the options object
  const swrOptionsObj = $.object()
    .pretty()
    .prop('key', keyCall)
    .prop(
      'fetcher',
      $.func()
        .async()
        .do(...statements),
    );

  const symbolSwrOptionsFn = plugin.symbol(
    buildName({
      config: plugin.config.swrOptions,
      name: operation.id,
    }),
    {
      meta: {
        category: 'hook',
        resource: 'operation',
        resourceId: operation.id,
        role: 'swrOptions',
        tool: plugin.name,
      },
    },
  );

  const statement = $.const(symbolSwrOptionsFn)
    .export()
    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>
      c.doc(v),
    )
    .assign(
      $.func()
        .param(optionsParamName, (p) =>
          p.optional(!isRequiredOptions).type(typeData),
        )
        .do($.return(swrOptionsObj)),
    );
  plugin.addNode(statement);
};
