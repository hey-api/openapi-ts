import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { log } from '@hey-api/codegen-core';
import type { PostProcessor, UserPostProcessor } from '@hey-api/shared';
import { findTsConfigPath, loadTsConfig, resolveSource, valueToObject } from '@hey-api/shared';
import type { MaybeArray } from '@hey-api/types';
import ts from 'typescript';

import { postProcessors } from './postprocess';
import type { Output, UserOutput } from './types';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export function getOutput(userConfig: { output: MaybeArray<string | UserOutput> }): Output {
  if (userConfig.output instanceof Array) {
    throw new Error(
      'Unexpected array of outputs in user configuration. This should have been expanded already.',
    );
  }

  const userOutput =
    typeof userConfig.output === 'string' ? { path: userConfig.output } : (userConfig.output ?? {});

  const legacyPostProcess = resolveLegacyPostProcess(userOutput);

  const output = valueToObject({
    defaultValue: {
      clean: true,
      entryFile: true,
      fileName: {
        case: 'preserve',
        name: '{{name}}',
        suffix: '.gen',
      },
      format: null,
      header: '// This file is auto-generated by @hey-api/openapi-ts',
      lint: null,
      path: '',
      postProcess: [],
      preferExportAll: false,
    },
    mappers: {
      object: (fields, defaultValue) => ({
        ...fields,
        fileName: valueToObject({
          defaultValue: {
            ...(defaultValue.fileName as Extract<
              typeof defaultValue.fileName,
              Record<string, unknown>
            >),
          },
          mappers: {
            function: (name) => ({ name }),
            string: (name) => ({ name }),
          },
          value: fields.fileName,
        }),
      }),
    },
    value: userOutput,
  }) as Output;
  output.tsConfig = loadTsConfig(findTsConfigPath(__dirname, output.tsConfigPath));
  if (
    output.importFileExtension === undefined &&
    (output.tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.NodeNext ||
      output.tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.Node16)
  ) {
    output.importFileExtension = '.js';
  }
  if (output.importFileExtension && !output.importFileExtension.startsWith('.')) {
    output.importFileExtension = `.${output.importFileExtension}`;
  }
  output.postProcess = normalizePostProcess(userOutput.postProcess ?? legacyPostProcess);
  output.source = resolveSource(output);
  return output;
}

function resolveLegacyPostProcess(config: Partial<UserOutput>): ReadonlyArray<UserPostProcessor> {
  const result: Array<UserPostProcessor> = [];

  if (config.lint !== undefined) {
    let processor: PostProcessor | undefined;
    let preset: keyof typeof postProcessors | undefined;
    if (config.lint) {
      preset = config.lint === 'biome' ? 'biome:lint' : config.lint;
      processor = postProcessors[preset];
      if (processor) result.push(processor);
    }

    log.warnDeprecated({
      context: 'output',
      field: 'lint',
      replacement: `postProcess: [${processor && preset ? `'${preset}'` : ''}]`,
    });
  }

  if (config.format !== undefined) {
    let processor: PostProcessor | undefined;
    let preset: keyof typeof postProcessors | undefined;
    if (config.format) {
      preset = config.format === 'biome' ? 'biome:format' : config.format;
      processor = postProcessors[preset];
      if (processor) result.push(processor);
    }

    log.warnDeprecated({
      context: 'output',
      field: 'format',
      replacement: `postProcess: [${processor && preset ? `'${preset}'` : ''}]`,
    });
  }

  return result;
}

function normalizePostProcess(input: UserOutput['postProcess']): ReadonlyArray<PostProcessor> {
  if (!input) return [];

  return input.map((item) => {
    if (typeof item === 'string') {
      const preset = postProcessors[item];
      if (!preset) {
        throw new Error(`Unknown post-processor preset: "${item}"`);
      }
      return preset;
    }
    return {
      name: item.name ?? item.command,
      ...item,
    };
  });
}
