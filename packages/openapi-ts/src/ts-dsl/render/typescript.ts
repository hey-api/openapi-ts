import type { RenderContext, Renderer } from '@hey-api/codegen-core';
import ts from 'typescript';

import { $ } from '~/ts-dsl';

import type {
  ModuleExport,
  ModuleImport,
  SortGroup,
  SortKey,
  SortModule,
} from './utils';
import { moduleSortKey, nodeToString } from './utils';

export class TypeScriptRenderer implements Renderer {
  /**
   * Whether `export * from 'module'` should be used when possible instead of named exports.
   *
   * @private
   */
  private preferExportAll: boolean;
  /**
   * Controls whether imports/exports include a file extension (e.g., '.ts' or '.js').
   *
   * @private
   */
  private preferFileExtension: string;
  /**
   * Optional function to transform module specifiers.
   *
   * @private
   */
  private resolveModuleName?: (moduleName: string) => string | undefined;

  constructor(
    args: {
      preferExportAll?: boolean;
      preferFileExtension?: string;
      resolveModuleName?: (moduleName: string) => string | undefined;
    } = {},
  ) {
    this.preferExportAll = args.preferExportAll ?? false;
    this.preferFileExtension = args.preferFileExtension ?? '';
    this.resolveModuleName = args.resolveModuleName;
  }

  render(ctx: RenderContext): string {
    let text = '';
    const header = '// This file is auto-generated by @hey-api/openapi-ts';
    text += `${header}\n`;

    let imports = '';
    for (const group of this.getImports(ctx)) {
      if (imports) imports += '\n';
      for (const imp of group) {
        imports += `${nodeToString(this.renderImport(ctx, imp))}\n`;
      }
    }
    text = `${text}${text && imports ? '\n' : ''}${imports}`;

    let nodes = '';
    for (const node of ctx.file.nodes) {
      if (nodes) nodes += '\n';
      // @ts-expect-error
      nodes += `${nodeToString(node.toAst(ctx.astContext))}\n`;
    }
    text = `${text}${text && nodes ? '\n' : ''}${nodes}`;

    let exports = '';
    for (const group of this.getExports(ctx)) {
      if ((!exports && nodes) || exports) exports += '\n';
      for (const exp of group) {
        exports += `${nodeToString(this.renderExport(ctx, exp))}\n`;
      }
    }
    text = `${text}${text && exports ? '\n' : ''}${exports}`;

    return text;
  }

  supports(ctx: RenderContext): boolean {
    return ctx.file.language === 'typescript';
  }

  private getExports(
    ctx: RenderContext,
  ): ReadonlyArray<ReadonlyArray<ModuleExport>> {
    type ModuleEntry = {
      group: ModuleExport;
      sortKey: SortKey;
    };

    const groups = new Map<SortGroup, Map<SortModule, ModuleEntry>>();

    for (const exp of ctx.file.exports) {
      const sortKey = moduleSortKey({
        file: ctx.file,
        fromFile: exp.from,
        preferFileExtension: this.preferFileExtension,
        root: ctx.project.root,
      });
      const modulePath = this.resolveModuleName?.(sortKey[2]) ?? sortKey[2];
      const [groupIndex] = sortKey;

      if (!groups.has(groupIndex)) groups.set(groupIndex, new Map());
      const moduleMap = groups.get(groupIndex)!;

      if (!moduleMap.has(modulePath)) {
        moduleMap.set(modulePath, {
          group: {
            canExportAll: exp.canExportAll,
            exports: exp.exports,
            isTypeOnly: exp.isTypeOnly,
            modulePath,
            namespaceExport: exp.namespaceExport,
          },
          sortKey,
        });
      }
    }

    const exports: Array<Array<ModuleExport>> = Array.from(groups.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([, moduleMap]) => {
        const entries = Array.from(moduleMap.values());

        entries.sort((a, b) => {
          const d = a.sortKey[1] - b.sortKey[1];
          return d !== 0
            ? d
            : a.group.modulePath.localeCompare(b.group.modulePath);
        });

        return entries.map((e) => {
          const group = e.group;
          if (group.namespaceExport) {
            group.exports = [];
          } else {
            const isTypeOnly = !group.exports.find((exp) => !exp.isTypeOnly);
            if (isTypeOnly) {
              group.isTypeOnly = true;
              for (const exp of group.exports) {
                exp.isTypeOnly = false;
              }
            }
            group.exports.sort((a, b) =>
              a.exportedName.localeCompare(b.exportedName),
            );
          }
          return group;
        });
      });

    return exports;
  }

  private getImports(
    ctx: RenderContext,
  ): ReadonlyArray<ReadonlyArray<ModuleImport>> {
    type ModuleEntry = {
      group: ModuleImport;
      sortKey: SortKey;
    };

    const groups = new Map<SortGroup, Map<SortModule, ModuleEntry>>();

    for (const imp of ctx.file.imports) {
      const sortKey = moduleSortKey({
        file: ctx.file,
        fromFile: imp.from,
        preferFileExtension: this.preferFileExtension,
        root: ctx.project.root,
      });
      const modulePath = this.resolveModuleName?.(sortKey[2]) ?? sortKey[2];
      const [groupIndex] = sortKey;

      if (!groups.has(groupIndex)) groups.set(groupIndex, new Map());
      const moduleMap = groups.get(groupIndex)!;

      if (!moduleMap.has(modulePath)) {
        moduleMap.set(modulePath, {
          group: {
            imports: [],
            isTypeOnly: false,
            modulePath,
          },
          sortKey,
        });
      }

      const entry = moduleMap.get(modulePath)!;
      const group = entry.group;

      if (imp.namespaceImport) {
        group.isTypeOnly = imp.isTypeOnly;
        group.namespaceImport = imp.namespaceImport;
      } else {
        group.imports.push(...imp.imports);
      }
    }

    const imports: Array<Array<ModuleImport>> = Array.from(groups.entries())
      .sort((a, b) => a[0] - b[0])
      .map(([, moduleMap]) => {
        const entries = Array.from(moduleMap.values());

        entries.sort((a, b) => {
          const d = a.sortKey[1] - b.sortKey[1];
          return d !== 0
            ? d
            : a.group.modulePath.localeCompare(b.group.modulePath);
        });

        return entries.map((e) => {
          const group = e.group;
          if (group.namespaceImport) {
            group.imports = [];
          } else {
            const isTypeOnly = !group.imports.find((imp) => !imp.isTypeOnly);
            if (isTypeOnly) {
              group.isTypeOnly = true;
              for (const imp of group.imports) {
                imp.isTypeOnly = false;
              }
            }
            group.imports.sort((a, b) =>
              a.localName.localeCompare(b.localName),
            );
          }
          return group;
        });
      });

    return imports;
  }

  private renderExport(
    ctx: RenderContext,
    group: ModuleExport,
  ): ts.ExportDeclaration {
    const specifiers = group.exports.map((exp) => {
      const specifier = ts.factory.createExportSpecifier(
        exp.isTypeOnly,
        exp.sourceName !== exp.exportedName
          ? $.id(exp.sourceName).toAst()
          : undefined,
        $.id(exp.exportedName).toAst(),
      );
      return specifier;
    });
    const exportClause = group.namespaceExport
      ? ts.factory.createNamespaceExport($.id(group.namespaceExport).toAst())
      : (!group.canExportAll || !this.preferExportAll) && specifiers.length
        ? ts.factory.createNamedExports(specifiers)
        : undefined;
    return ts.factory.createExportDeclaration(
      undefined,
      group.isTypeOnly,
      exportClause,
      $.literal(group.modulePath).toAst(ctx.astContext),
    );
  }

  private renderImport(
    ctx: RenderContext,
    group: ModuleImport,
  ): ts.ImportDeclaration {
    const specifiers = group.imports.map((imp) => {
      const specifier = ts.factory.createImportSpecifier(
        imp.isTypeOnly,
        imp.sourceName !== imp.localName
          ? $.id(imp.sourceName).toAst()
          : undefined,
        $.id(imp.localName).toAst(),
      );
      return specifier;
    });
    const importClause = ts.factory.createImportClause(
      group.isTypeOnly,
      undefined, // TODO: default imports
      group.namespaceImport
        ? ts.factory.createNamespaceImport($.id(group.namespaceImport).toAst())
        : ts.factory.createNamedImports(specifiers),
    );
    return ts.factory.createImportDeclaration(
      undefined,
      importClause,
      $.literal(group.modulePath).toAst(ctx.astContext),
    );
  }
}
