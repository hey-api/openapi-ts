import fs from 'node:fs';
import path from 'node:path';

import ts from 'typescript';

import type { IR } from '../../ir/types';
import { getUniqueComponentName } from '../../openApi/shared/transforms/utils';
import { ensureValidIdentifier } from '../../openApi/shared/utils/identifier';
import { tsc } from '../../tsc';
import { type ImportExportItemObject, tsNodeToString } from '../../tsc/utils';
import type { StringCase } from '../../types/case';
import { stringCase } from '../../utils/stringCase';
import { ensureDirSync } from '../utils';
import type {
  FileImportResult,
  Identifier,
  Identifiers,
  Namespace,
  NodeInfo,
  NodeReference,
} from './types';
export class GeneratedFile {
  private _case: StringCase | undefined;
  /**
   * Should the exports from this file be re-exported in the index barrel file?
   */
  private _exportFromIndex: boolean;
  private _headers: Array<string> = [];
  private _id: string;
  private _imports = new Map<string, Map<string, ImportExportItemObject>>();
  private _items: Array<ts.Node | string> = [];
  private _name: string;
  private _path: string;

  /** @deprecated use `names` and `nodes` */
  public identifiers: Identifiers = {};

  /**
   * Map of node IDs. This can be used to obtain actual node names. Keys are
   * node IDs which can be any string, values are names. Values are kept in
   * sync with `nodes`.
   *
   * @example
   * ```json
   * {
   *   "#/my-id": "final_name",
   *   "anyId": "name"
   * }
   * ```
   */
  private names: Record<string, string> = {};
  /**
   * Another approach for named nodes, with proper support for renaming. Keys
   * are node IDs and values are an array of references for given ID.
   */
  private nodeReferences: Record<string, Array<NodeReference>> = {};
  /**
   * Text value from node is kept in sync with `names`.
   *
   * @deprecated
   * @example
   * ```js
   * {
   *   "#/my-id": {
   *     "node": TypeReferenceNode
   *   },
   *   "anyId": {
   *     "node": TypeReferenceNode
   *   }
   * }
   * ```
   */
  // TODO: nodes can be possibly replaced with `nodeReferences`, i.e. keep
  // the name `nodes` and rewrite their functionality
  private nodes: Record<string, NodeInfo> = {};

  /**
   * Path relative to the client output root.
   */
  // TODO: parser - add relative path property for quick access, currently
  // everything is resolved into an absolute path with cwd
  // public relativePath: string;

  public constructor({
    case: _case,
    dir,
    exportFromIndex = false,
    header = true,
    id,
    name,
  }: {
    case?: StringCase;
    dir: string;
    /**
     * Should the exports from this file be re-exported in the index barrel file?
     */
    exportFromIndex?: boolean;
    header?: boolean;
    /**
     * Unique file ID. Used to generate correct relative paths to the file.
     * This should be refactored later as it's basically the file name unless
     * nested inside another folder.
     */
    id: string;
    name: string;
  }) {
    this._case = _case;
    this._exportFromIndex = exportFromIndex;
    this._id = id;
    this._name = this._setName(name);
    this._path = path.resolve(dir, this._name);

    if (header) {
      this._headers.push(
        '// This file is auto-generated by @hey-api/openapi-ts',
      );
    }
  }

  public add(...nodes: Array<ts.Node | string>) {
    this._items = this._items.concat(nodes);
  }

  /**
   * Adds a reference node for a name. This can be used later to rename
   * identifiers.
   */
  public addNodeReference<T>(
    id: string,
    node: Pick<NodeReference<T>, 'factory'>,
  ): T {
    if (!this.nodeReferences[id]) {
      this.nodeReferences[id] = [];
    }
    const result = node.factory(this.names[id] ?? '');
    this.nodeReferences[id].push({
      factory: node.factory,
      node: result as void,
    });
    return result;
  }

  /**
   * Prevents a specific identifier from being created. This is useful for
   * transformers where we know a certain transformer won't be needed, and
   * we want to avoid attempting to create since we know it won't happen.
   */
  public blockIdentifier({
    $ref,
    namespace,
  }: Pick<EnsureUniqueIdentifierData, '$ref'> & {
    namespace: Namespace;
  }): Identifier {
    const { name, ref } = parseRef($ref);
    const refValue =
      this.identifiers[name.toLocaleLowerCase()]?.[namespace]?.[ref];
    if (!refValue) {
      throw new Error(
        `Identifier for $ref ${$ref} in namespace ${namespace} not found`,
      );
    }

    refValue.name = false;

    return {
      created: false,
      name: refValue.name,
    };
  }

  public get exportFromIndex(): boolean {
    return this._exportFromIndex;
  }

  /**
   * Returns an actual node name. If node doesn't exist throws an error.
   *
   * @param id Node ID.
   * @returns Actual node name.
   */
  public getName(id: string): string | undefined {
    const name = this.names[id];
    if (!name) {
      return;
    }
    return name;
  }

  /**
   * Returns a node. If node doesn't exist, creates a blank reference.
   *
   * @deprecated
   * @param id Node ID.
   * @returns Information about the node.
   */
  public getNode(id: string): NodeInfo {
    if (!this.nodes[id]) {
      this.nodes[id] = {
        node: tsc.typeReferenceNode({ typeName: '' }),
      };
    }
    return this.nodes[id]!;
  }

  public get id(): string {
    return this._id;
  }

  /** @deprecated use `names` and `nodes` */
  public identifier(
    args: Pick<
      EnsureUniqueIdentifierData,
      '$ref' | 'count' | 'create' | 'nameTransformer'
    > & {
      case?: StringCase;
      namespace: Namespace;
    },
  ): Identifier {
    return ensureUniqueIdentifier({
      case: args.case ?? this._case,
      identifiers: this.identifiers,
      ...args,
    });
  }

  /**
   * Adds an import to the provided module. Handles duplication, returns added
   * import. Returns the imported name. If we import an aliased export, `name`
   * will be equal to the specified `alias`.
   */
  public import<
    Name extends string | undefined = string | undefined,
    Alias extends string | undefined = undefined,
  >({
    module,
    ...importedItem
  }: ImportExportItemObject<Name, Alias> & {
    module: string;
  }): FileImportResult<Name, Alias> {
    if (!importedItem.name) {
      return {
        name: undefined as any,
      };
    }

    let moduleMap = this._imports.get(module);

    if (!moduleMap) {
      moduleMap = new Map<string, ImportExportItemObject>();
      this._imports.set(module, moduleMap);
    }

    const match = moduleMap.get(importedItem.name);
    if (match) {
      return {
        ...match,
        name: (match.alias || match.name) as any,
      };
    }

    moduleMap.set(importedItem.name, importedItem as any);
    return {
      ...importedItem,
      name: (importedItem.alias || importedItem.name) as any,
    };
  }

  public isEmpty() {
    return !this._items.length;
  }

  public nameWithoutExtension() {
    const { name } = splitNameAndExtension(this._name);
    return name;
  }

  public relativePathToFile({
    context,
    id,
  }: {
    context: IR.Context;
    id: string;
  }): string {
    let filePath = '';

    // relative file path
    if (id.startsWith('.')) {
      let configFileParts: Array<string> = [];
      // if providing a custom configuration file, relative paths must resolve
      // relative to the configuration file.
      if (context.config.configFile) {
        const cfgParts = context.config.configFile.split('/');
        configFileParts = cfgParts.slice(0, cfgParts.length - 1);
      }
      filePath = path.resolve(process.cwd(), ...configFileParts, id);
    } else {
      const file = context.file({ id });
      if (!file) {
        throw new Error(`File with id ${id} does not exist`);
      }
      filePath = file._path;
    }

    const thisPathParts = this._path.split(path.sep);
    const filePathParts = filePath.split(path.sep);

    let index = -1;
    let relativePath = '';
    for (const part of thisPathParts) {
      index += 1;
      if (filePathParts[index] !== part) {
        const pathArray = Array.from({
          length: thisPathParts.length - index,
        }).fill('');
        const relativePathToFile = filePathParts.slice(index);
        const relativeFolder = relativePathToFile.slice(
          0,
          relativePathToFile.length - 1,
        );
        if (relativeFolder.length) {
          relativeFolder.push('');
        }
        relativePath =
          (pathArray.join('../') || './') + relativeFolder.join('/');
        break;
      }
    }

    const fileName = filePathParts[filePathParts.length - 1]!;
    // TODO: parser - cache responses
    return `${relativePath}${splitNameAndExtension(fileName).name}`;
  }

  public remove(options?: Parameters<typeof fs.rmSync>[1]) {
    fs.rmSync(this._path, options);
  }

  /**
   * Removes last node form the stack. Works as undo.
   *
   * @deprecated
   */
  public removeNode_LEGACY() {
    this._items = this._items.slice(0, this._items.length - 1);
  }

  private _setName(fileName: string) {
    if (fileName.includes('index')) {
      return fileName;
    }

    const { extension, name } = splitNameAndExtension(fileName);
    return [name, 'gen', extension].filter(Boolean).join('.');
  }

  private _toString(separator: string, tsConfig: ts.ParsedCommandLine | null) {
    let output: Array<string> = [];
    if (this._headers.length) {
      output.push(this._headers.join('\n'));
    }

    const shouldAppendJs =
      tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.NodeNext;

    const importsStringArray: Array<string> = [];

    for (const [_module, moduleMap] of this._imports.entries()) {
      const imports = Array.from(moduleMap.values());

      let resolvedModule = _module;
      if (
        shouldAppendJs &&
        (resolvedModule.startsWith('./') || resolvedModule.startsWith('../'))
      ) {
        if (resolvedModule === './client') {
          resolvedModule = './client/index.js';
        } else {
          resolvedModule = `${resolvedModule}.js`;
        }
      }

      const node = tsc.namedImportDeclarations({
        imports,
        module: resolvedModule,
      });
      importsStringArray.push(tsNodeToString({ node }));
    }
    if (importsStringArray.length) {
      output.push(importsStringArray.join('\n'));
    }
    output = output.concat(
      this._items.map((node) =>
        typeof node === 'string'
          ? node
          : tsNodeToString({ node, unescape: true }),
      ),
    );
    return output.join(separator);
  }

  /**
   * Inserts or updates a node.
   *
   * @deprecated
   * @param id Node ID.
   * @param args Information about the node.
   * @returns Updated node.
   */
  public updateNode(
    id: string,
    args: Pick<NodeInfo, 'exported'> & {
      name: string;
    },
  ): NodeInfo {
    // update name
    const name = getUniqueComponentName({
      base: ensureValidIdentifier(args.name),
      components: Object.values(this.names),
    });
    this.names[id] = name;
    const node = tsc.typeReferenceNode({ typeName: name });
    // update node
    if (!this.nodes[id]) {
      this.nodes[id] = { node };
    } else {
      Object.assign(this.nodes[id].node, node);
    }
    if (args.exported !== undefined) {
      this.nodes[id].exported = args.exported;
    }
    return this.nodes[id];
  }

  /**
   * Updates collected reference nodes for a name with the latest value.
   *
   * @param id Node ID.
   * @param name Updated name for the nodes.
   * @returns noop
   */
  public updateNodeReferences(id: string, name: string): void {
    if (!this.nodeReferences[id]) {
      return;
    }
    const finalName = getUniqueComponentName({
      base: ensureValidIdentifier(name),
      components: Object.values(this.names),
    });
    this.names[id] = finalName;
    for (const node of this.nodeReferences[id]) {
      const nextNode = node.factory(finalName);
      Object.assign(node.node as unknown as object, nextNode);
    }
  }

  public write(separator = '\n', tsConfig: ts.ParsedCommandLine | null = null) {
    if (this.isEmpty()) {
      this.remove({ force: true });
      return;
    }

    let dir = this._path;
    if (typeof this._path === 'string') {
      const parts = this._path.split(path.sep);
      dir = parts.slice(0, parts.length - 1).join(path.sep);
    }
    ensureDirSync(dir);
    fs.writeFileSync(this._path, this._toString(separator, tsConfig));
  }
}

const parseRef = (
  $ref: string,
): {
  /**
   * Extracted name from `$ref`, equal to the last part or property name.
   */
  name: string;
  /**
   * List of properties extracted from `$ref`, if any.
   */
  properties: ReadonlyArray<string>;
  /**
   * `$ref` without properties if they're included in `$ref`, otherwise
   * `ref` is equal to `$ref`.
   */
  ref: string;
} => {
  let ref = $ref;
  const properties: string[] = [];

  const parts = ref.split('/');
  let name = parts[parts.length - 1] || '';

  let propIndex = parts.indexOf('properties');

  if (propIndex !== -1) {
    ref = parts.slice(0, propIndex).join('/');
    name = parts[propIndex - 1] || '';

    while (propIndex + 1 < parts.length) {
      const prop = parts[propIndex + 1];
      if (!prop) {
        throw new Error(`Invalid $ref: ${$ref}`);
      }
      properties.push(prop);
      propIndex += 2;
    }
  }

  return {
    name,
    properties,
    ref,
  };
};

const transformName = (
  name: string,
  transformer: ((name: string) => string) | string,
  _case?: StringCase,
): string => {
  if (typeof transformer === 'function') {
    return transformer(name);
  }

  const separator = _case === 'preserve' ? '' : '-';
  return transformer.replace('{{name}}', `${separator}${name}${separator}`);
};

interface EnsureUniqueIdentifierData {
  $ref: string;
  case: StringCase | undefined;
  count?: number;
  create?: boolean;
  identifiers: Identifiers;
  /**
   * Transforms name obtained from `$ref` before it's passed to `stringCase()`.
   */
  nameTransformer?: ((name: string) => string) | string;
  namespace: Namespace;
}

const ensureUniqueIdentifier = ({
  $ref,
  case: _case,
  count = 1,
  create = false,
  identifiers,
  nameTransformer,
  namespace,
}: EnsureUniqueIdentifierData): Identifier => {
  const { name, properties, ref } = parseRef($ref);

  if (!name) {
    return {
      created: false,
      name: '',
    };
  }

  let nameWithCasingAndTransformer = stringCase({
    case: _case,
    value: nameTransformer ? transformName(name, nameTransformer, _case) : name,
  });
  if (count > 1) {
    nameWithCasingAndTransformer = `${nameWithCasingAndTransformer}${count}`;
  }
  const lowercaseName = nameWithCasingAndTransformer.toLocaleLowerCase();
  if (!identifiers[lowercaseName]) {
    identifiers[lowercaseName] = {};
  }
  const identifier = identifiers[lowercaseName];

  // Enum declarations can only merge with namespace or other enum
  // declarations, so we need to ensure we don't mix them up.
  if (
    (namespace === 'enum' && (identifier.type || identifier.value)) ||
    (namespace !== 'enum' && identifier.enum)
  ) {
    return ensureUniqueIdentifier({
      $ref: ref,
      case: _case,
      count: count + 1,
      create,
      identifiers,
      nameTransformer,
      namespace,
    });
  }

  if (!identifier[namespace]) {
    identifier[namespace] = {};
  }
  const id = identifier[namespace];

  const refValue = id[ref];
  if (refValue) {
    let name = refValue.name;
    if (properties.length) {
      name += properties.map((property) => `['${property}']`).join('');
    }
    return {
      created: false,
      name: name as string,
    };
  }

  let nameValue = id[nameWithCasingAndTransformer];
  if (nameValue) {
    if (nameValue.$ref === ref) {
      return {
        created: false,
        name: nameValue.name,
      };
    }

    return ensureUniqueIdentifier({
      $ref: ref,
      case: _case,
      count: count + 1,
      create,
      identifiers,
      nameTransformer,
      namespace,
    });
  }

  if (!create) {
    delete identifier[namespace];
    return {
      created: false,
      name: '',
    };
  }

  nameValue = {
    $ref: ref,
    name: ensureValidIdentifier(nameWithCasingAndTransformer),
  };
  id[nameWithCasingAndTransformer] = nameValue;
  id[nameValue.$ref] = nameValue;

  return {
    created: true,
    name: nameValue.name,
  };
};

export const splitNameAndExtension = (fileName: string) => {
  const match = fileName.match(/\.[0-9a-z]+$/i);
  const extension = match ? match[0].slice(1) : '';
  const name = fileName.slice(
    0,
    fileName.length - (extension ? extension.length + 1 : 0),
  );
  return { extension, name };
};

export const _test = {
  ensureUniqueIdentifier,
  parseRef,
};
