import path from 'node:path';

import type {
  Binding,
  File,
  IProject,
  PlannedImport,
  PlannedReexport,
  Project,
  ProjectRenderMeta,
  Renderer,
  Symbol,
} from '@hey-api/codegen-core';
import { createBinding, mergeBindings, renderIds } from '@hey-api/codegen-core';
import ts from 'typescript';

import { ensureValidIdentifier } from '~/openApi/shared/utils/identifier';
import { $, isTsDsl } from '~/ts-dsl';

const printer = ts.createPrinter({
  newLine: ts.NewLineKind.LineFeed,
  removeComments: false,
});

const createSourceFile = (sourceText: string): ts.SourceFile =>
  ts.createSourceFile(
    '',
    sourceText,
    ts.ScriptTarget.ESNext,
    false,
    ts.ScriptKind.TS,
  );

const blankSourceFile = createSourceFile('');

const unescapeUnicode = (value: string) =>
  value.replace(/\\u([0-9a-fA-F]{4})/g, (_, hex: string) =>
    String.fromCharCode(Number.parseInt(hex, 16)),
  );

/** Print a TypeScript node to a string. */
function nodeToString(node: ts.Node): string {
  const result = printer.printNode(
    ts.EmitHint.Unspecified,
    node,
    blankSourceFile,
  );

  try {
    /**
     * TypeScript Compiler API escapes unicode characters by default and there
     * is no way to disable this behavior
     * {@link https://github.com/microsoft/TypeScript/issues/36174}
     */
    return unescapeUnicode(result);
  } catch {
    return result;
  }
}

const nodeBuiltins = new Set([
  'buffer',
  'child_process',
  'cluster',
  'console',
  'constants',
  'crypto',
  'dgram',
  'dns',
  'domain',
  'events',
  'freelist',
  'fs',
  'http',
  'https',
  'module',
  'net',
  'os',
  'path',
  'process',
  'punycode',
  'querystring',
  'readline',
  'repl',
  'stream',
  'string_decoder',
  'timers',
  'tls',
  'tty',
  'url',
  'util',
  'v8',
  'vm',
  'worker_threads',
  'zlib',
]);

export class TypeScriptRenderer implements Renderer {
  render(file: File, project: Project, meta?: ProjectRenderMeta): string {
    let output = '';
    const header = '// This file is auto-generated by @hey-api/openapi-ts';
    output += `${header}\n`;

    let outputImports = '';
    for (const plan of file.imports) {
      outputImports += nodeToString(
        this.renderImport(plan, file, project, meta),
      );
      outputImports += '\n';
    }
    output = `${output}${output && outputImports ? '\n' : ''}${outputImports}`;

    let outputSymbols = '';
    for (const symbol of file.symbols) {
      if (outputSymbols) outputSymbols += '\n';
      const node = symbol.node;
      if (isTsDsl(node)) {
        outputSymbols += nodeToString(node.$render());
      }
      outputSymbols += '\n';
    }
    output = `${output}${output && outputSymbols ? '\n' : ''}${outputSymbols}`;

    let outputReexports = '';
    for (const plan of file.reexports) {
      if (!outputReexports && outputSymbols) outputReexports += '\n';
      outputReexports += nodeToString(
        this.renderExport(plan, file, project, meta),
      );
      outputReexports += '\n';
    }
    output = `${output}${output && outputReexports ? '\n' : ''}${outputReexports}`;

    return output;
  }

  private renderExport(
    plan: PlannedReexport,
    file: File,
    project: Project,
    meta?: ProjectRenderMeta,
  ): ts.ExportDeclaration {
    const modulePath = this.getBindingPath(
      file,
      project.files.get(plan.from)!,
      meta,
    );
    const specifier = ts.factory.createExportSpecifier(
      false,
      plan.importedName !== plan.exportedName
        ? $.id(plan.importedName).$render()
        : undefined,
      $.id(plan.exportedName).$render(),
    );
    return ts.factory.createExportDeclaration(
      undefined,
      plan.isTypeOnly,
      ts.factory.createNamedExports([specifier]),
      $.literal(modulePath).$render(),
    );
  }

  private renderImport(
    plan: PlannedImport,
    file: File,
    project: Project,
    meta?: ProjectRenderMeta,
  ): ts.ImportDeclaration {
    const modulePath = this.getBindingPath(
      file,
      project.files.get(plan.from)!,
      meta,
    );
    const localName = $.id(plan.localName).$render();
    const specifier = ts.factory.createImportSpecifier(
      false,
      plan.importedName !== plan.localName
        ? $.id(plan.importedName).$render()
        : undefined,
      localName,
    );
    const importClause = ts.factory.createImportClause(
      false,
      plan.kind === 'default' ? localName : undefined,
      plan.kind === 'namespace'
        ? ts.factory.createNamespaceImport(localName)
        : ts.factory.createNamedImports([specifier]),
    );
    return ts.factory.createImportDeclaration(
      undefined,
      importClause,
      $.literal(modulePath).$render(),
    );
  }

  renderFile(
    symbolsAndExports: string,
    file: File,
    project: IProject,
    meta?: ProjectRenderMeta,
  ): string {
    const imports: Map<string, Binding> = new Map();
    symbolsAndExports = renderIds(symbolsAndExports, (symbolId) => {
      const symbol = project.symbols.get(symbolId);
      const replaced = this.replacerFn({ file, project, symbol });
      if (symbol) {
        this.addBinding({ bindings: imports, file, meta, project, symbol });
      }
      return replaced;
    });
    if (!symbolsAndExports.length) return '';
    let output = '';
    const headerLines = this.getHeaderLines();
    output += `${headerLines.join('\n')}${headerLines.length ? '\n\n' : ''}`;
    const importLines = this.getImportLines(imports, file, project);
    output += `${importLines.join('\n')}${importLines.length ? '\n\n' : ''}`;
    return `${output}${symbolsAndExports}`;
  }

  renderSymbols(file: File, project: IProject): string {
    const exports: Map<string, Binding> = new Map();
    let output = '';
    const bodyLines: Array<string> = [];
    output += `${bodyLines.join('\n\n')}${bodyLines.length ? '\n' : ''}`;
    // cast everything into namespace exports for now
    for (const binding of exports.values()) {
      binding.namespaceBinding = true;
      binding.typeNamespaceBinding =
        binding.names &&
        binding.typeNames &&
        binding.names.length === binding.typeNames.length &&
        binding.names.every((name) => (binding.typeNames ?? []).includes(name));
    }
    const exportLines = this.getExportLines(exports, file, project);
    output += `${exportLines.join('\n')}${exportLines.length ? '\n' : ''}`;
    return output;
  }

  private addBinding({
    bindings,
    file,
    meta,
    project,
    symbol,
  }: {
    bindings: Map<string, Binding>;
    file: File;
    meta?: ProjectRenderMeta;
    project: IProject;
    symbol: Symbol;
  }): void {
    if (!symbol.external && !project.symbols.hasValue(symbol.id)) {
      return;
    }

    const symbolFile: File | undefined = undefined;
    if (!symbolFile || file === symbolFile) return;

    const modulePath = this.getBindingPath(file, symbolFile, meta);
    const existing = bindings.get(modulePath);
    const binding = createBinding({
      file,
      modulePath,
      symbol,
      symbolFile,
    });
    if (existing) {
      mergeBindings(existing, binding);
      bindings.set(modulePath, existing);
    } else {
      bindings.set(modulePath, binding);
    }
  }

  private getBindingPath(
    currentFile: File,
    symbolFile: File,
    meta?: ProjectRenderMeta,
  ): string {
    if (!currentFile.path || !symbolFile.path) {
      return '';
    }
    if (symbolFile.external && !path.isAbsolute(symbolFile.path)) {
      return symbolFile.path;
    }
    let relativePath = path.posix.relative(
      path.posix.dirname(
        currentFile.path.split(path.sep).join(path.posix.sep), // normalize to posix
      ),
      symbolFile.path.split(path.sep).join(path.posix.sep), // normalize to posix
    );
    if (!relativePath.startsWith('.') && relativePath !== '') {
      relativePath = `./${relativePath}`;
    }
    if (symbolFile.extension === '.ts') {
      if (relativePath.endsWith(symbolFile.extension)) {
        relativePath = relativePath.slice(0, -symbolFile.extension.length);
      }
      if (meta?.importFileExtension) {
        relativePath += meta.importFileExtension;
      } else if (relativePath.endsWith('/index')) {
        relativePath = relativePath.slice(0, -'/index'.length);
      }
    }
    return relativePath;
  }

  private getExportLines(
    bindings: Map<string, Binding>,
    file: File,
    project: IProject,
  ): Array<string> {
    const lines: Array<string> = [];

    for (const [from, value] of bindings.entries()) {
      const specifiers: Array<ts.ExportSpecifier> = [];
      let namespaceBinding: string | undefined;
      let isTypeOnly = false;

      if (value.namespaceBinding !== undefined) {
        if (typeof value.namespaceBinding === 'string') {
          namespaceBinding = renderIds(value.namespaceBinding, (symbolId) => {
            const symbol = project.symbols.get(symbolId);
            return this.replacerFn({ file, project, symbol });
          });
        }
        if (value.typeNamespaceBinding) {
          isTypeOnly = true;
        }
      } else if (value.names && value.names.length > 0) {
        if (
          value.names.every((name) => (value.typeNames ?? []).includes(name))
        ) {
          isTypeOnly = true;
        }

        for (const name of value.names) {
          const alias = value.aliases?.[name];
          let finalName = name;
          let finalAlias: string | undefined;
          if (alias && alias !== finalName) {
            finalAlias = finalName;
            finalName = alias;
          }
          finalName = renderIds(finalName, (symbolId) => {
            const symbol = project.symbols.get(symbolId);
            const name = this.replacerFn({ file, project, symbol });
            const symbolFile: File | undefined = undefined;
            const sourceName = symbolFile
              ? // @ts-expect-error
                symbolFile.resolvedNames.get(symbolId)
              : undefined;
            if (sourceName && sourceName !== name) {
              // handle only simple imports for now
              if (!finalAlias) {
                finalAlias = sourceName;
              }
            }
            return name;
          });
          if (finalAlias) {
            finalAlias = renderIds(finalAlias, (symbolId) => {
              const symbol = project.symbols.get(symbolId);
              return this.replacerFn({ file, project, symbol });
            });
            // remove redundant alias
            if (finalAlias === finalName) {
              finalAlias = undefined;
            }
          }
          const specifier = ts.factory.createExportSpecifier(
            isTypeOnly ? false : (value.typeNames?.includes(name) ?? false),
            finalAlias ? $.id(finalAlias).$render() : undefined,
            $.id(finalName).$render(),
          );
          specifiers.push(specifier);
        }
      }

      const exportClause = namespaceBinding
        ? ts.factory.createNamespaceExport($.id(namespaceBinding).$render())
        : specifiers.length
          ? ts.factory.createNamedExports(specifiers)
          : undefined;

      const node = ts.factory.createExportDeclaration(
        undefined,
        isTypeOnly,
        exportClause,
        $.literal(from).$render(),
      );
      lines.push(nodeToString(node));
    }

    return lines;
  }

  private getHeaderLines(): Array<string> {
    return ['// This file is auto-generated by @hey-api/openapi-ts'];
  }

  private getImportLines(
    bindings: Map<string, Binding>,
    file: File,
    project: IProject,
  ): Array<string> {
    const lines: Array<string> = [];

    let lastGroup = -1;
    const importSortKey = (binding: Binding): [number, number, string] => {
      const path = binding.from;
      if (!path.startsWith('.')) {
        // Node.js built-in
        if (nodeBuiltins.has(path.split('/')[0]!)) {
          return [0, 0, path];
        }
        // external package
        return [1, 0, path];
      }
      // sibling relative
      if (path.startsWith('./')) {
        return [2, 0, path];
      }
      // parent relative
      const parentCount = path.match(/\.\.\//g)?.length ?? 0;
      return [2, parentCount, path];
    };

    const sortedBindings = Array.from(bindings.values())
      .map((value) => ({
        ...value,
        k: importSortKey(value),
      }))
      .sort(
        (a, b) =>
          a.k[0] - b.k[0] || a.k[1] - b.k[1] || a.k[2].localeCompare(b.k[2]),
      );

    for (const value of sortedBindings) {
      let specifiers: Array<ts.ImportSpecifier> = [];
      let defaultBinding: ts.Identifier | undefined;
      let namespaceBinding: string | undefined;
      let isTypeOnly = false;

      if (value.defaultBinding) {
        const processedDefaultBinding = renderIds(
          value.defaultBinding,
          (symbolId) => {
            const symbol = project.symbols.get(symbolId);
            return this.replacerFn({ file, project, symbol });
          },
        );
        defaultBinding = $.id(processedDefaultBinding).$render();
        if (value.typeDefaultBinding) {
          isTypeOnly = true;
        }
      } else if (typeof value.namespaceBinding === 'string') {
        namespaceBinding = renderIds(value.namespaceBinding, (symbolId) => {
          const symbol = project.symbols.get(symbolId);
          return this.replacerFn({ file, project, symbol });
        });
        if (value.typeNamespaceBinding) {
          isTypeOnly = true;
        }
      } else if (value.names && value.names.length > 0) {
        if (value.names.every((name) => value.typeNames?.includes(name))) {
          isTypeOnly = true;
        }

        const namedImports: Array<{
          isTypeOnly: boolean;
          name: string;
          propertyName: ts.ModuleExportName | undefined;
        }> = [];

        for (const name of value.names) {
          const alias = value.aliases?.[name];
          let finalName = name;
          let finalAlias: string | undefined;
          if (alias && alias !== finalName) {
            finalAlias = finalName;
            finalName = alias;
          }
          finalName = renderIds(finalName, (symbolId) => {
            const symbol = project.symbols.get(symbolId);
            const name = this.replacerFn({ file, project, symbol });
            const symbolFile: File | undefined = undefined;
            const sourceName = symbolFile
              ? // @ts-expect-error
                symbolFile.resolvedNames.get(symbolId)
              : undefined;
            if (sourceName && sourceName !== name) {
              // handle only simple imports for now
              if (!finalAlias) {
                finalAlias = sourceName;
              }
            }
            return name;
          });
          if (finalAlias) {
            finalAlias = renderIds(finalAlias, (symbolId) => {
              const symbol = project.symbols.get(symbolId);
              return this.replacerFn({ file, project, symbol });
            });
            // remove redundant alias
            if (finalAlias === finalName) {
              finalAlias = undefined;
            }
          }
          namedImports.push({
            isTypeOnly: isTypeOnly
              ? false
              : (value.typeNames?.includes(name) ?? false),
            name: finalName,
            propertyName: finalAlias ? $.id(finalAlias).$render() : undefined,
          });
        }

        specifiers = namedImports
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(({ isTypeOnly, name, propertyName }) =>
            ts.factory.createImportSpecifier(
              isTypeOnly,
              propertyName,
              $.id(name).$render(),
            ),
          );
      }

      const importClause = ts.factory.createImportClause(
        isTypeOnly,
        defaultBinding,
        namespaceBinding
          ? ts.factory.createNamespaceImport($.id(namespaceBinding).$render())
          : specifiers.length
            ? ts.factory.createNamedImports(specifiers)
            : undefined,
      );

      const node = ts.factory.createImportDeclaration(
        undefined,
        importClause,
        $.literal(value.from).$render(),
      );

      if (lastGroup !== -1 && value.k[0] !== lastGroup) {
        lines.push(''); // add empty line between groups
      }

      lines.push(nodeToString(node));
      lastGroup = value.k[0];
    }

    return lines;
  }

  private getUniqueName({
    base,
    file,
    index,
    project,
    symbol,
  }: {
    base: string;
    file: File;
    index: number;
    project: IProject;
    symbol: Symbol;
  }): string {
    let name = index > 1 ? `${base}${index}` : base;
    if (!file.resolvedNames.hasValue(name)) {
      return name;
    }
    const conflictIds = file.resolvedNames.getKeys(name) ?? new Set();
    const conflictSymbols = [...conflictIds]
      .map((id) => project.symbols.get(id))
      .filter((s): s is NonNullable<typeof s> => s !== undefined);
    if (conflictSymbols.length > 0) {
      const conflictKinds = conflictSymbols.map((s) => s.kind);
      // avoid conflicts between class and type of the same name
      if (
        (symbol.kind === 'type' &&
          (conflictKinds.includes('type') ||
            conflictKinds.includes('class'))) ||
        (symbol.kind !== 'type' &&
          conflictKinds.some((kind) => kind !== 'type')) ||
        (symbol.kind === 'class' && conflictKinds.includes('type'))
      ) {
        name = this.getUniqueName({
          base,
          file,
          index: index + 1,
          project,
          symbol,
        });
      }
    }
    return name;
  }

  private replacerFn({
    file,
    project,
    symbol,
  }: {
    file: File;
    project: IProject;
    symbol: Symbol | undefined;
  }): string | undefined {
    if (!symbol) return;
    const cached = file.resolvedNames.get(symbol.id);
    if (cached) return cached;
    if (!symbol.name) return;
    const symbolFile: File | undefined = undefined;
    // @ts-expect-error
    const symbolFileResolvedName = symbolFile?.resolvedNames.get(symbol.id);
    const name = this.getUniqueName({
      base: ensureValidIdentifier(symbolFileResolvedName ?? symbol.name),
      file,
      index: 1,
      project,
      symbol,
    });
    file.resolvedNames.set(symbol.id, name);
    return name;
  }
}
