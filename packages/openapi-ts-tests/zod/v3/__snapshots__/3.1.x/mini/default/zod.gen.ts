// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod/v4-mini';

/**
 * Model with number-only name
 */
export const z400 = z.string();

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCamelCaseCommentWithBreaks = z.int();

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCommentWithBreaks = z.int();

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const zCommentWithBackticks = z.int();

/**
 * Testing backticks and quotes in string: `backticks`, 'quotes', "double quotes" and ```multiple backticks``` should work
 */
export const zCommentWithBackticksAndQuotes = z.int();

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const zCommentWithSlashes = z.int();

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const zCommentWithExpressionPlaceholders = z.int();

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const zCommentWithQuotes = z.int();

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const zCommentWithReservedCharacters = z.int();

/**
 * This is a simple number
 */
export const zSimpleInteger = z.int();

/**
 * This is a simple boolean
 */
export const zSimpleBoolean = z.boolean();

/**
 * This is a simple string
 */
export const zSimpleString = z.string();

/**
 * A string with non-ascii (unicode) characters valid in typescript identifiers (æøåÆØÅöÔèÈ字符串)
 */
export const zNonAsciiStringæøåÆøÅöôêÊ字符串 = z.string();

/**
 * This is a simple file
 */
export const zSimpleFile = z.string();

/**
 * This is a model with one string property
 */
export const zModelWithString = z.object({
    prop: z.optional(z.string())
});

/**
 * This is a simple reference
 */
export const zSimpleReference = zModelWithString;

/**
 * This is a simple string
 */
export const zSimpleStringWithPattern = z.union([
    z.string().check(z.maxLength(64), z.regex(/^[a-zA-Z0-9_]*$/)),
    z.null()
]);

/**
 * This is a simple enum with strings
 */
export const zEnumWithStrings = z.enum([
    'Success',
    'Warning',
    'Error',
    "'Single Quote'",
    '"Double Quotes"',
    'Non-ascii: øæåôöØÆÅÔÖ字符串'
]);

export const zEnumWithReplacedCharacters = z.enum([
    "'Single Quote'",
    '"Double Quotes"',
    'øæåôöØÆÅÔÖ字符串',
    ''
]);

/**
 * This is a simple enum with numbers
 */
export const zEnumWithNumbers = z.unknown();

/**
 * Success=1,Warning=2,Error=3
 */
export const zEnumFromDescription = z.number();

/**
 * This is a simple enum with numbers
 */
export const zEnumWithExtensions = z.unknown();

export const zEnumWithXEnumNames = z.unknown();

/**
 * This is a simple array with numbers
 */
export const zArrayWithNumbers = z.array(z.int());

/**
 * This is a simple array with booleans
 */
export const zArrayWithBooleans = z.array(z.boolean());

/**
 * This is a simple array with strings
 */
export const zArrayWithStrings = z._default(z.array(z.string()), ['test']);

/**
 * This is a simple array with references
 */
export const zArrayWithReferences = z.array(zModelWithString);

/**
 * This is a simple array containing an array
 */
export const zArrayWithArray = z.array(z.array(zModelWithString));

/**
 * This is a simple array with properties
 */
export const zArrayWithProperties = z.array(z.object({
    '16x16': z.optional(zCamelCaseCommentWithBreaks),
    bar: z.optional(z.string())
}));

/**
 * This is a simple array with any of properties
 */
export const zArrayWithAnyOfProperties = z.array(z.union([
    z.object({
        foo: z._default(z.optional(z.string()), 'test')
    }),
    z.object({
        bar: z.optional(z.string())
    })
]));

export const zAnyOfAnyAndNull = z.object({
    data: z.optional(z.union([
        z.unknown(),
        z.null()
    ]))
});

/**
 * This is a simple array with any of properties
 */
export const zAnyOfArrays = z.object({
    results: z.optional(z.array(z.union([
        z.object({
            foo: z.optional(z.string())
        }),
        z.object({
            bar: z.optional(z.string())
        })
    ])))
});

/**
 * This is a string dictionary
 */
export const zDictionaryWithString = z.record(z.string(), z.string());

export const zDictionaryWithPropertiesAndAdditionalProperties = z.object({
    foo: z.optional(z.number()),
    bar: z.optional(z.boolean())
});

/**
 * This is a string reference
 */
export const zDictionaryWithReference = z.record(z.string(), zModelWithString);

/**
 * This is a complex dictionary
 */
export const zDictionaryWithArray = z.record(z.string(), z.array(zModelWithString));

/**
 * This is a string dictionary
 */
export const zDictionaryWithDictionary = z.record(z.string(), z.record(z.string(), z.string()));

/**
 * This is a complex dictionary
 */
export const zDictionaryWithProperties = z.record(z.string(), z.object({
    foo: z.optional(z.string()),
    bar: z.optional(z.string())
}));

/**
 * This is a model with one number property
 */
export const zModelWithInteger = z.object({
    prop: z.optional(z.int())
});

/**
 * This is a model with one boolean property
 */
export const zModelWithBoolean = z.object({
    prop: z.optional(z.boolean())
});

/**
 * This is a model with one string property
 */
export const zModelWithStringError = z.object({
    prop: z.optional(z.string())
});

/**
 * `Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)
 */
export const zModelFromZendesk = z.string();

/**
 * This is a model with one string property
 */
export const zModelWithNullableString = z.object({
    nullableProp1: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    nullableRequiredProp1: z.union([
        z.string(),
        z.null()
    ]),
    nullableProp2: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    nullableRequiredProp2: z.union([
        z.string(),
        z.null()
    ]),
    'foo_bar-enum': z.optional(z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ]))
});

/**
 * This is a model with one enum
 */
export const zModelWithEnum = z.object({
    'foo_bar-enum': z.optional(z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ])),
    statusCode: z.optional(z.enum([
        '100',
        '200 FOO',
        '300 FOO_BAR',
        '400 foo-bar',
        '500 foo.bar',
        '600 foo&bar'
    ])),
    bool: z.optional(z.unknown())
});

/**
 * This is a model with one enum with escaped name
 */
export const zModelWithEnumWithHyphen = z.object({
    'foo-bar-baz-qux': z.optional(z.enum([
        '3.0'
    ]))
});

/**
 * This is a model with one enum
 */
export const zModelWithEnumFromDescription = z.object({
    test: z.optional(z.int())
});

/**
 * This is a model with nested enums
 */
export const zModelWithNestedEnums = z.object({
    dictionaryWithEnum: z.optional(z.record(z.string(), z.enum([
        'Success',
        'Warning',
        'Error'
    ]))),
    dictionaryWithEnumFromDescription: z.optional(z.record(z.string(), z.int())),
    arrayWithEnum: z.optional(z.array(z.enum([
        'Success',
        'Warning',
        'Error'
    ]))),
    arrayWithDescription: z.optional(z.array(z.int())),
    'foo_bar-enum': z.optional(z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ]))
});

/**
 * This is a model with one nested property
 */
export const zModelWithProperties = z.object({
    required: z.string(),
    requiredAndReadOnly: z.readonly(z.string()),
    requiredAndNullable: z.union([
        z.string(),
        z.null()
    ]),
    string: z.optional(z.string()),
    number: z.optional(z.number()),
    boolean: z.optional(z.boolean()),
    reference: z.optional(zModelWithString),
    'property with space': z.optional(z.string()),
    default: z.optional(z.string()),
    try: z.optional(z.string()),
    '@namespace.string': z.optional(z.readonly(z.string())),
    '@namespace.integer': z.optional(z.readonly(z.int()))
});

/**
 * This is a model with one property containing a reference
 */
export const zModelWithReference = z.object({
    prop: z.optional(zModelWithProperties)
});

export const zModelWithReadOnlyAndWriteOnly = z.object({
    foo: z.string(),
    bar: z.readonly(z.string())
});

/**
 * This is a model with one property containing an array
 */
export const zModelWithArrayReadOnlyAndWriteOnly = z.object({
    prop: z.optional(z.array(zModelWithReadOnlyAndWriteOnly)),
    propWithFile: z.optional(z.array(z.string())),
    propWithNumber: z.optional(z.array(z.number()))
});

/**
 * This is a model with one property containing an array
 */
export const zModelWithArray = z.object({
    prop: z.optional(z.array(zModelWithString)),
    propWithFile: z.optional(z.array(z.string())),
    propWithNumber: z.optional(z.array(z.number()))
});

/**
 * This is a model with one property containing a dictionary
 */
export const zModelWithDictionary = z.object({
    prop: z.optional(z.record(z.string(), z.string()))
});

/**
 * This is a deprecated model with a deprecated property
 * @deprecated
 */
export const zDeprecatedModel = z.object({
    prop: z.optional(z.string())
});

/**
 * This is a model with one property containing a circular reference
 */
export const zModelWithCircularReference = z.object({
    get prop(): z.ZodMiniOptional {
        return z.optional(z.lazy((): any => {
            return zModelWithCircularReference;
        }));
    }
});

/**
 * This is a model with one property with a 'one of' relationship
 */
export const zCompositionWithOneOf = z.object({
    propA: z.optional(z.union([
        zModelWithString,
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary
    ]))
});

/**
 * This is a model with one property with a 'one of' relationship where the options are not $ref
 */
export const zCompositionWithOneOfAnonymous = z.object({
    propA: z.optional(z.union([
        z.object({
            propA: z.optional(z.string())
        }),
        z.string(),
        z.int()
    ]))
});

/**
 * Circle
 */
export const zModelCircle = z.object({
    kind: z.string(),
    radius: z.optional(z.number())
});

/**
 * Square
 */
export const zModelSquare = z.object({
    kind: z.string(),
    sideLength: z.optional(z.number())
});

/**
 * This is a model with one property with a 'one of' relationship where the options are not $ref
 */
export const zCompositionWithOneOfDiscriminator = z.union([
    z.intersection(z.object({
        kind: z.literal('circle')
    }), zModelCircle),
    z.intersection(z.object({
        kind: z.literal('square')
    }), zModelSquare)
]);

/**
 * This is a model with one property with a 'any of' relationship
 */
export const zCompositionWithAnyOf = z.object({
    propA: z.optional(z.union([
        zModelWithString,
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary
    ]))
});

/**
 * This is a model with one property with a 'any of' relationship where the options are not $ref
 */
export const zCompositionWithAnyOfAnonymous = z.object({
    propA: z.optional(z.union([
        z.object({
            propA: z.optional(z.string())
        }),
        z.string(),
        z.int()
    ]))
});

/**
 * This is a model with nested 'any of' property with a type null
 */
export const zCompositionWithNestedAnyAndTypeNull = z.object({
    propA: z.optional(z.union([
        z.array(z.union([
            zModelWithDictionary,
            z.null()
        ])),
        z.array(z.union([
            zModelWithArray,
            z.null()
        ]))
    ]))
});

export const z3eNum1Период = z.enum([
    'Bird',
    'Dog'
]);

export const zConstValue = z.literal('ConstValue');

/**
 * This is a model with one property with a 'any of' relationship where the options are not $ref
 */
export const zCompositionWithNestedAnyOfAndNull = z.object({
    propA: z.optional(z.union([
        z.array(z.union([
            z3eNum1Период,
            zConstValue
        ])),
        z.null()
    ]))
});

/**
 * This is a model with one property with a 'one of' relationship
 */
export const zCompositionWithOneOfAndNullable = z.object({
    propA: z.optional(z.union([
        z.object({
            boolean: z.optional(z.boolean())
        }),
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary,
        z.null()
    ]))
});

/**
 * This is a model that contains a simple dictionary within composition
 */
export const zCompositionWithOneOfAndSimpleDictionary = z.object({
    propA: z.optional(z.union([
        z.boolean(),
        z.record(z.string(), z.number())
    ]))
});

/**
 * This is a model that contains a dictionary of simple arrays within composition
 */
export const zCompositionWithOneOfAndSimpleArrayDictionary = z.object({
    propA: z.optional(z.union([
        z.boolean(),
        z.record(z.string(), z.array(z.boolean()))
    ]))
});

/**
 * This is a model that contains a dictionary of complex arrays (composited) within composition
 */
export const zCompositionWithOneOfAndComplexArrayDictionary = z.object({
    propA: z.optional(z.union([
        z.boolean(),
        z.record(z.string(), z.array(z.union([
            z.number(),
            z.string()
        ])))
    ]))
});

/**
 * This is a model with one property with a 'all of' relationship
 */
export const zCompositionWithAllOfAndNullable = z.object({
    propA: z.optional(z.union([
        z.intersection(z.intersection(z.intersection(z.object({
            boolean: z.optional(z.boolean())
        }), zModelWithEnum), zModelWithArray), zModelWithDictionary),
        z.null()
    ]))
});

/**
 * This is a model with one property with a 'any of' relationship
 */
export const zCompositionWithAnyOfAndNullable = z.object({
    propA: z.optional(z.union([
        z.object({
            boolean: z.optional(z.boolean())
        }),
        zModelWithEnum,
        zModelWithArray,
        zModelWithDictionary,
        z.null()
    ]))
});

/**
 * This is a base model with two simple optional properties
 */
export const zCompositionBaseModel = z.object({
    firstName: z.optional(z.string()),
    lastname: z.optional(z.string())
});

/**
 * This is a model that extends the base model
 */
export const zCompositionExtendedModel = z.intersection(zCompositionBaseModel, z.object({
    age: z.number(),
    firstName: z.string(),
    lastname: z.string()
}));

/**
 * This is a model with one nested property
 */
export const zModelWithNestedProperties = z.object({
    first: z.readonly(z.union([
        z.readonly(z.object({
            second: z.readonly(z.union([
                z.readonly(z.object({
                    third: z.readonly(z.union([
                        z.readonly(z.string()),
                        z.null()
                    ]))
                })),
                z.null()
            ]))
        })),
        z.null()
    ]))
});

/**
 * This is a model with duplicated properties
 */
export const zModelWithDuplicateProperties = z.object({
    prop: z.optional(zModelWithString)
});

/**
 * This is a model with ordered properties
 */
export const zModelWithOrderedProperties = z.object({
    zebra: z.optional(z.string()),
    apple: z.optional(z.string()),
    hawaii: z.optional(z.string())
});

/**
 * This is a model with duplicated imports
 */
export const zModelWithDuplicateImports = z.object({
    propA: z.optional(zModelWithString),
    propB: z.optional(zModelWithString),
    propC: z.optional(zModelWithString)
});

/**
 * This is a model that extends another model
 */
export const zModelThatExtends = z.intersection(zModelWithString, z.object({
    propExtendsA: z.optional(z.string()),
    propExtendsB: z.optional(zModelWithString)
}));

/**
 * This is a model that extends another model
 */
export const zModelThatExtendsExtends = z.intersection(z.intersection(zModelWithString, zModelThatExtends), z.object({
    propExtendsC: z.optional(z.string()),
    propExtendsD: z.optional(zModelWithString)
}));

/**
 * This is a model that contains a some patterns
 */
export const zModelWithPattern = z.object({
    key: z.string().check(z.maxLength(64), z.regex(/^[a-zA-Z0-9_]*$/)),
    name: z.string().check(z.maxLength(255)),
    enabled: z.optional(z.readonly(z.boolean())),
    modified: z.optional(z.readonly(z.iso.datetime())),
    id: z.optional(z.string().check(z.regex(/^\d{2}-\d{3}-\d{4}$/))),
    text: z.optional(z.string().check(z.regex(/^\w+$/))),
    patternWithSingleQuotes: z.optional(z.string().check(z.regex(/^[a-zA-Z0-9']*$/))),
    patternWithNewline: z.optional(z.string().check(z.regex(/aaa\nbbb/))),
    patternWithBacktick: z.optional(z.string().check(z.regex(/aaa`bbb/)))
});

export const zFile = z.object({
    id: z.optional(z.readonly(z.string().check(z.minLength(1)))),
    updated_at: z.optional(z.readonly(z.iso.datetime())),
    created_at: z.optional(z.readonly(z.iso.datetime())),
    mime: z.string().check(z.minLength(1), z.maxLength(24)),
    file: z.optional(z.readonly(z.url()))
});

export const zDefault = z.object({
    name: z.optional(z.string())
});

export const zPageable = z.object({
    page: z._default(z.optional(z.int().check(z.gte(0))), 0),
    size: z.optional(z.int().check(z.gte(1))),
    sort: z.optional(z.array(z.string()))
});

/**
 * This is a free-form object without additionalProperties.
 */
export const zFreeFormObjectWithoutAdditionalProperties = z.record(z.string(), z.unknown());

/**
 * This is a free-form object with additionalProperties: true.
 */
export const zFreeFormObjectWithAdditionalPropertiesEqTrue = z.record(z.string(), z.unknown());

/**
 * This is a free-form object with additionalProperties: {}.
 */
export const zFreeFormObjectWithAdditionalPropertiesEqEmptyObject = z.record(z.string(), z.unknown());

export const zModelWithConst = z.object({
    String: z.optional(z.literal('String')),
    number: z.optional(z.literal(0)),
    null: z.optional(z.null()),
    withType: z.optional(z.literal('Some string'))
});

/**
 * This is a model with one property and additionalProperties: true
 */
export const zModelWithAdditionalPropertiesEqTrue = z.object({
    prop: z.optional(z.string())
});

export const zNestedAnyOfArraysNullable = z.object({
    nullableArray: z.optional(z.union([
        z.array(z.union([
            z.string(),
            z.boolean()
        ])),
        z.null()
    ]))
});

/**
 * This is a reusable parameter
 */
export const zSimpleParameter = z.unknown();

export const zCompositionWithOneOfAndProperties = z.intersection(z.union([
    z.object({
        foo: zSimpleParameter
    }),
    z.object({
        bar: zNonAsciiStringæøåÆøÅöôêÊ字符串
    })
]), z.object({
    baz: z.union([
        z.int().check(z.gte(0)),
        z.null()
    ]),
    qux: z.int().check(z.gte(0))
}));

/**
 * An object that can be null
 */
export const zNullableObject = z._default(z.union([
    z.object({
        foo: z.optional(z.string())
    }),
    z.null()
]), null);

/**
 * Some % character
 */
export const zCharactersInDescription = z.string();

export const zModelWithNullableObject = z.object({
    data: z.optional(zNullableObject)
});

export const zModelWithOneOfEnum = z.union([
    z.object({
        foo: z.enum([
            'Bar'
        ])
    }),
    z.object({
        foo: z.enum([
            'Baz'
        ])
    }),
    z.object({
        foo: z.enum([
            'Qux'
        ])
    }),
    z.object({
        content: z.iso.datetime(),
        foo: z.enum([
            'Quux'
        ])
    }),
    z.object({
        content: z.tuple([
            z.iso.datetime(),
            z.string()
        ]),
        foo: z.enum([
            'Corge'
        ])
    })
]);

export const zModelWithNestedArrayEnumsDataFoo = z.enum([
    'foo',
    'bar'
]);

export const zModelWithNestedArrayEnumsDataBar = z.enum([
    'baz',
    'qux'
]);

export const zModelWithNestedArrayEnumsData = z.object({
    foo: z.optional(z.array(zModelWithNestedArrayEnumsDataFoo)),
    bar: z.optional(z.array(zModelWithNestedArrayEnumsDataBar))
});

export const zModelWithNestedArrayEnums = z.object({
    array_strings: z.optional(z.array(z.string())),
    data: z.optional(zModelWithNestedArrayEnumsData)
});

export const zModelWithNestedCompositionEnums = z.object({
    foo: z.optional(zModelWithNestedArrayEnumsDataFoo)
});

export const zModelWithConstantSizeArray = z.tuple([
    z.number(),
    z.number()
]);

export const zModelWithAnyOfConstantSizeArray = z.tuple([
    z.union([
        z.number(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.string()
    ])
]);

export const zModelWithPrefixItemsConstantSizeArray = z.tuple([
    zModelWithInteger,
    z.union([
        z.number(),
        z.string()
    ]),
    z.string()
]);

export const zModelWithAnyOfConstantSizeArrayNullable = z.tuple([
    z.union([
        z.number(),
        z.null(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.null(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.null(),
        z.string()
    ])
]);

/**
 * Model with restricted keyword name
 */
export const zImport = z.string();

export const zModelWithAnyOfConstantSizeArrayWithNSizeAndOptions = z.tuple([
    z.union([
        z.number(),
        zImport
    ]),
    z.union([
        z.number(),
        zImport
    ])
]);

export const zModelWithAnyOfConstantSizeArrayAndIntersect = z.tuple([
    z.intersection(z.number(), z.string()),
    z.intersection(z.number(), z.string())
]);

export const zModelWithNumericEnumUnion = z.object({
    value: z.optional(z.unknown())
});

/**
 * Some description with `back ticks`
 */
export const zModelWithBackticksInDescription = z.object({
    template: z.optional(z.string())
});

export const zModelWithOneOfAndProperties = z.intersection(z.union([
    zSimpleParameter,
    zNonAsciiStringæøåÆøÅöôêÊ字符串
]), z.object({
    baz: z.union([
        z.int().check(z.gte(0)),
        z.null()
    ]),
    qux: z.int().check(z.gte(0))
}));

/**
 * Model used to test deduplication strategy (unused)
 */
export const zParameterSimpleParameterUnused = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zPostServiceWithEmptyTagResponse = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zPostServiceWithEmptyTagResponse2 = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zDeleteFooData = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zDeleteFooData2 = z.string();

export const zSchemaWithFormRestrictedKeys = z.object({
    description: z.optional(z.string()),
    'x-enum-descriptions': z.optional(z.string()),
    'x-enum-varnames': z.optional(z.string()),
    'x-enumNames': z.optional(z.string()),
    title: z.optional(z.string()),
    object: z.optional(z.object({
        description: z.optional(z.string()),
        'x-enum-descriptions': z.optional(z.string()),
        'x-enum-varnames': z.optional(z.string()),
        'x-enumNames': z.optional(z.string()),
        title: z.optional(z.string())
    })),
    array: z.optional(z.array(z.object({
        description: z.optional(z.string()),
        'x-enum-descriptions': z.optional(z.string()),
        'x-enum-varnames': z.optional(z.string()),
        'x-enumNames': z.optional(z.string()),
        title: z.optional(z.string())
    })))
});

/**
 * This schema was giving PascalCase transformations a hard time
 */
export const zIoK8sApimachineryPkgApisMetaV1Preconditions = z.object({
    resourceVersion: z.optional(z.string()),
    uid: z.optional(z.string())
});

/**
 * This schema was giving PascalCase transformations a hard time
 */
export const zIoK8sApimachineryPkgApisMetaV1DeleteOptions = z.object({
    preconditions: z.optional(zIoK8sApimachineryPkgApisMetaV1Preconditions)
});

export const zAdditionalPropertiesUnknownIssue = z.record(z.string(), z.union([
    z.string(),
    z.number()
]));

export const zAdditionalPropertiesUnknownIssue2 = z.record(z.string(), z.union([
    z.string(),
    z.number()
]));

export const zAdditionalPropertiesUnknownIssue3 = z.intersection(z.string(), z.object({
    entries: z.record(z.string(), zAdditionalPropertiesUnknownIssue)
}));

export const zAdditionalPropertiesIntegerIssue = z.object({
    value: z.int()
});

export const zGenericSchemaDuplicateIssue1SystemBoolean = z.object({
    item: z.optional(z.boolean()),
    error: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hasError: z.optional(z.readonly(z.boolean())),
    data: z.optional(z.record(z.string(), z.never()))
});

export const zGenericSchemaDuplicateIssue1SystemString = z.object({
    item: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    error: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    hasError: z.optional(z.readonly(z.boolean()))
});

export const zOneOfAllOfIssue = z.union([
    z.intersection(z.union([
        zConstValue,
        zGenericSchemaDuplicateIssue1SystemBoolean
    ]), z3eNum1Период),
    zGenericSchemaDuplicateIssue1SystemString
]);

/**
 * Model with number-only name
 */
export const z400Writable = z.string();

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCamelCaseCommentWithBreaksWritable = z.int();

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCommentWithBreaksWritable = z.int();

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const zCommentWithBackticksWritable = z.int();

/**
 * Testing backticks and quotes in string: `backticks`, 'quotes', "double quotes" and ```multiple backticks``` should work
 */
export const zCommentWithBackticksAndQuotesWritable = z.int();

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const zCommentWithSlashesWritable = z.int();

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const zCommentWithExpressionPlaceholdersWritable = z.int();

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const zCommentWithQuotesWritable = z.int();

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const zCommentWithReservedCharactersWritable = z.int();

/**
 * This is a simple number
 */
export const zSimpleIntegerWritable = z.int();

/**
 * This is a simple boolean
 */
export const zSimpleBooleanWritable = z.boolean();

/**
 * This is a simple string
 */
export const zSimpleStringWritable = z.string();

/**
 * A string with non-ascii (unicode) characters valid in typescript identifiers (æøåÆØÅöÔèÈ字符串)
 */
export const zNonAsciiStringæøåÆøÅöôêÊ字符串Writable = z.string();

/**
 * This is a simple file
 */
export const zSimpleFileWritable = z.string();

/**
 * This is a simple string
 */
export const zSimpleStringWithPatternWritable = z.union([
    z.string().check(z.maxLength(64), z.regex(/^[a-zA-Z0-9_]*$/)),
    z.null()
]);

/**
 * This is a simple enum with strings
 */
export const zEnumWithStringsWritable = z.enum([
    'Success',
    'Warning',
    'Error',
    "'Single Quote'",
    '"Double Quotes"',
    'Non-ascii: øæåôöØÆÅÔÖ字符串'
]);

export const zEnumWithReplacedCharactersWritable = z.enum([
    "'Single Quote'",
    '"Double Quotes"',
    'øæåôöØÆÅÔÖ字符串',
    ''
]);

/**
 * This is a simple enum with numbers
 */
export const zEnumWithNumbersWritable = z.unknown();

/**
 * Success=1,Warning=2,Error=3
 */
export const zEnumFromDescriptionWritable = z.number();

/**
 * This is a simple enum with numbers
 */
export const zEnumWithExtensionsWritable = z.unknown();

export const zEnumWithXEnumNamesWritable = z.unknown();

/**
 * This is a simple array with numbers
 */
export const zArrayWithNumbersWritable = z.array(z.int());

/**
 * This is a simple array with booleans
 */
export const zArrayWithBooleansWritable = z.array(z.boolean());

/**
 * This is a simple array with strings
 */
export const zArrayWithStringsWritable = z._default(z.array(z.string()), ['test']);

/**
 * This is a string dictionary
 */
export const zDictionaryWithStringWritable = z.record(z.string(), z.string());

/**
 * This is a string dictionary
 */
export const zDictionaryWithDictionaryWritable = z.record(z.string(), z.record(z.string(), z.string()));

/**
 * `Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)
 */
export const zModelFromZendeskWritable = z.string();

export const zModelWithReadOnlyAndWriteOnlyWritable = z.object({
    foo: z.string(),
    baz: z.string()
});

/**
 * This is a model with one property containing an array
 */
export const zModelWithArrayReadOnlyAndWriteOnlyWritable = z.object({
    prop: z.optional(z.array(zModelWithReadOnlyAndWriteOnlyWritable)),
    propWithFile: z.optional(z.array(z.string())),
    propWithNumber: z.optional(z.array(z.number()))
});

export const z3eNum1ПериодWritable = z.enum([
    'Bird',
    'Dog'
]);

export const zConstValueWritable = z.literal('ConstValue');

/**
 * This is a free-form object without additionalProperties.
 */
export const zFreeFormObjectWithoutAdditionalPropertiesWritable = z.record(z.string(), z.unknown());

/**
 * This is a free-form object with additionalProperties: true.
 */
export const zFreeFormObjectWithAdditionalPropertiesEqTrueWritable = z.record(z.string(), z.unknown());

/**
 * This is a free-form object with additionalProperties: {}.
 */
export const zFreeFormObjectWithAdditionalPropertiesEqEmptyObjectWritable = z.record(z.string(), z.unknown());

/**
 * Some % character
 */
export const zCharactersInDescriptionWritable = z.string();

export const zModelWithNestedArrayEnumsDataFooWritable = z.enum([
    'foo',
    'bar'
]);

export const zModelWithNestedArrayEnumsDataBarWritable = z.enum([
    'baz',
    'qux'
]);

export const zModelWithConstantSizeArrayWritable = z.tuple([
    z.number(),
    z.number()
]);

export const zModelWithAnyOfConstantSizeArrayWritable = z.tuple([
    z.union([
        z.number(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.string()
    ])
]);

export const zModelWithAnyOfConstantSizeArrayNullableWritable = z.tuple([
    z.union([
        z.number(),
        z.null(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.null(),
        z.string()
    ]),
    z.union([
        z.number(),
        z.null(),
        z.string()
    ])
]);

/**
 * Model with restricted keyword name
 */
export const zImportWritable = z.string();

export const zModelWithAnyOfConstantSizeArrayWithNSizeAndOptionsWritable = z.tuple([
    z.union([
        z.number(),
        zImportWritable
    ]),
    z.union([
        z.number(),
        zImportWritable
    ])
]);

export const zModelWithAnyOfConstantSizeArrayAndIntersectWritable = z.tuple([
    z.intersection(z.number(), z.string()),
    z.intersection(z.number(), z.string())
]);

/**
 * Model used to test deduplication strategy (unused)
 */
export const zParameterSimpleParameterUnusedWritable = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zPostServiceWithEmptyTagResponseWritable = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zPostServiceWithEmptyTagResponse2Writable = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zDeleteFooDataWritable = z.string();

/**
 * Model used to test deduplication strategy
 */
export const zDeleteFooData2Writable = z.string();

export const zAdditionalPropertiesUnknownIssueWritable = z.record(z.string(), z.union([
    z.string(),
    z.number()
]));

export const zAdditionalPropertiesUnknownIssue2Writable = z.record(z.string(), z.union([
    z.string(),
    z.number()
]));

export const zOneOfAllOfIssueWritable = z.union([
    z.intersection(z.union([
        zConstValueWritable,
        zGenericSchemaDuplicateIssue1SystemBoolean
    ]), z3eNum1Период),
    zGenericSchemaDuplicateIssue1SystemString
]);

/**
 * Parameter with illegal characters
 */
export const zXFooBar = zModelWithString;

/**
 * A reusable request body
 */
export const zSimpleRequestBody = zModelWithString;

/**
 * A reusable request body
 */
export const zSimpleFormData = zModelWithString;

export const zExportData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPatchApiVbyApiVersionNoTagData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zImportData = z.object({
    body: z.union([
        zModelWithReadOnlyAndWriteOnlyWritable,
        zModelWithArrayReadOnlyAndWriteOnlyWritable
    ]),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zImportResponse = z.union([
    zModelFromZendesk,
    zModelWithReadOnlyAndWriteOnly
]);

export const zFooWowData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zApiVVersionODataControllerCountData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zApiVVersionODataControllerCountResponse = zModelFromZendesk;

export const zGetApiVbyApiVersionSimpleOperationData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        foo_param: z.union([
            z.string(),
            z.uuid()
        ])
    }),
    query: z.optional(z.never())
});

/**
 * Response is a simple number
 */
export const zGetApiVbyApiVersionSimpleOperationResponse = z.number();

export const zDeleteCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zHeadCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zOptionsCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPatchCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPostCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPutCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDeleteFooData3 = z.object({
    body: z.optional(z.never()),
    path: z.object({
        foo_param: z.string(),
        BarParam: z.string()
    }),
    query: z.optional(z.never()),
    headers: z.object({
        'x-Foo-Bar': zModelWithString
    })
});

export const zCallWithDescriptionsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameterWithBreaks: z.optional(z.string()),
        parameterWithBackticks: z.optional(z.string()),
        parameterWithSlashes: z.optional(z.string()),
        parameterWithExpressionPlaceholders: z.optional(z.string()),
        parameterWithQuotes: z.optional(z.string()),
        parameterWithReservedCharacters: z.optional(z.string())
    }))
});

export const zDeprecatedCallData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        parameter: z.union([
            zDeprecatedModel,
            z.null()
        ])
    })
});

export const zCallWithParametersData = z.object({
    body: z.union([
        z.record(z.string(), z.unknown()),
        z.null()
    ]),
    path: z.object({
        parameterPath: z.union([
            z.string(),
            z.null()
        ]),
        'api-version': z.union([
            z.string(),
            z.null()
        ])
    }),
    query: z.object({
        foo_ref_enum: z.optional(zModelWithNestedArrayEnumsDataFooWritable),
        foo_all_of_enum: zModelWithNestedArrayEnumsDataFooWritable,
        cursor: z.union([
            z.string(),
            z.null()
        ])
    }),
    headers: z.object({
        parameterHeader: z.union([
            z.string(),
            z.null()
        ])
    })
});

export const zCallWithWeirdParameterNamesData = z.object({
    body: z.union([
        zModelWithString,
        z.null()
    ]),
    path: z.object({
        'parameter.path.1': z.optional(z.string()),
        'parameter-path-2': z.optional(z.string()),
        'PARAMETER-PATH-3': z.optional(z.string()),
        'api-version': z.union([
            z.string(),
            z.null()
        ])
    }),
    query: z.object({
        default: z.optional(z.string()),
        'parameter-query': z.union([
            z.string(),
            z.null()
        ])
    }),
    headers: z.object({
        'parameter.header': z.union([
            z.string(),
            z.null()
        ])
    })
});

export const zGetCallWithOptionalParamData = z.object({
    body: zModelWithOneOfEnum,
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.number())
    }))
});

export const zPostCallWithOptionalParamData = z.object({
    body: z.optional(z.object({
        offset: z.optional(z.union([
            z.number(),
            z.null()
        ]))
    })),
    path: z.optional(z.never()),
    query: z.object({
        parameter: zPageable
    })
});

export const zPostCallWithOptionalParamResponse = z.union([
    z.number(),
    z.void()
]);

export const zPostApiVbyApiVersionRequestBodyData = z.object({
    body: z.optional(zSimpleRequestBody),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameter: z.optional(z.string())
    }))
});

export const zPostApiVbyApiVersionFormDataData = z.object({
    body: z.optional(zSimpleFormData),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameter: z.optional(z.string())
    }))
});

export const zCallWithDefaultParametersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameterString: z._default(z.optional(z.union([
            z._default(z.string(), 'Hello World!'),
            z.null()
        ])), 'Hello World!'),
        parameterNumber: z._default(z.optional(z.union([
            z._default(z.number(), 123),
            z.null()
        ])), 123),
        parameterBoolean: z._default(z.optional(z.union([
            z._default(z.boolean(), true),
            z.null()
        ])), true),
        parameterEnum: z.optional(z.enum([
            'Success',
            'Warning',
            'Error'
        ])),
        parameterModel: z.optional(z.union([
            zModelWithString,
            z.null()
        ]))
    }))
});

export const zCallWithDefaultOptionalParametersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameterString: z._default(z.optional(z.string()), 'Hello World!'),
        parameterNumber: z._default(z.optional(z.number()), 123),
        parameterBoolean: z._default(z.optional(z.boolean()), true),
        parameterEnum: z.optional(z.enum([
            'Success',
            'Warning',
            'Error'
        ])),
        parameterModel: z.optional(zModelWithString)
    }))
});

export const zCallToTestOrderOfParamsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterOptionalStringWithDefault: z._default(z.optional(z.string()), 'Hello World!'),
        parameterOptionalStringWithEmptyDefault: z._default(z.optional(z.string()), ''),
        parameterOptionalStringWithNoDefault: z.optional(z.string()),
        parameterStringWithDefault: z._default(z.string(), 'Hello World!'),
        parameterStringWithEmptyDefault: z._default(z.string(), ''),
        parameterStringWithNoDefault: z.string(),
        parameterStringNullableWithNoDefault: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        parameterStringNullableWithDefault: z._default(z.optional(z.union([
            z.string(),
            z.null()
        ])), null)
    })
});

export const zDuplicateNameData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDuplicateName2Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDuplicateName3Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDuplicateName4Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithNoContentResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zCallWithNoContentResponseResponse = z.void();

export const zCallWithResponseAndNoContentResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponseAndNoContentResponseResponse = z.union([
    z.number(),
    z.void()
]);

export const zDummyAData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDummyAResponse = z400;

export const zDummyBData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zDummyBResponse = z.void();

export const zCallWithResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponseResponse = zImport;

export const zCallWithDuplicateResponsesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithDuplicateResponsesResponse = z.union([
    z.intersection(zModelWithBoolean, zModelWithInteger),
    zModelWithString
]);

export const zCallWithResponsesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponsesResponse = z.union([
    z.object({
        '@namespace.string': z.optional(z.readonly(z.string())),
        '@namespace.integer': z.optional(z.readonly(z.int())),
        value: z.optional(z.readonly(z.array(zModelWithString)))
    }),
    zModelThatExtends,
    zModelThatExtendsExtends
]);

export const zCollectionFormatData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterArrayCSV: z.union([
            z.array(z.string()),
            z.null()
        ]),
        parameterArraySSV: z.union([
            z.array(z.string()),
            z.null()
        ]),
        parameterArrayTSV: z.union([
            z.array(z.string()),
            z.null()
        ]),
        parameterArrayPipes: z.union([
            z.array(z.string()),
            z.null()
        ]),
        parameterArrayMulti: z.union([
            z.array(z.string()),
            z.null()
        ])
    })
});

export const zTypesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.object({
        id: z.optional(z.int())
    })),
    query: z.object({
        parameterNumber: z._default(z.number(), 123),
        parameterString: z._default(z.union([
            z._default(z.string(), 'default'),
            z.null()
        ]), 'default'),
        parameterBoolean: z._default(z.union([
            z._default(z.boolean(), true),
            z.null()
        ]), true),
        parameterObject: z._default(z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]), null),
        parameterArray: z.union([
            z.array(z.string()),
            z.null()
        ]),
        parameterDictionary: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        parameterEnum: z.union([
            z.literal('Success'),
            z.literal('Warning'),
            z.literal('Error'),
            z.null()
        ])
    })
});

export const zTypesResponse = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.record(z.string(), z.unknown())
]);

export const zUploadFileData = z.object({
    body: z.string(),
    path: z.object({
        'api-version': z.union([
            z.string(),
            z.null()
        ])
    }),
    query: z.optional(z.never())
});

export const zUploadFileResponse = z.boolean();

export const zFileResponseData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string(),
        'api-version': z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zFileResponseResponse = z.string();

export const zComplexTypesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterObject: z.object({
            first: z.optional(z.object({
                second: z.optional(z.object({
                    third: z.optional(z.string())
                }))
            }))
        }),
        parameterReference: zModelWithString
    })
});

/**
 * Successful response
 */
export const zComplexTypesResponse = z.array(zModelWithString);

export const zMultipartResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * OK
 */
export const zMultipartResponseResponse = z.object({
    file: z.optional(z.string()),
    metadata: z.optional(z.object({
        foo: z.optional(z.string()),
        bar: z.optional(z.string())
    }))
});

export const zMultipartRequestData = z.object({
    body: z.optional(z.object({
        content: z.optional(z.string()),
        data: z.optional(z.union([
            zModelWithString,
            z.null()
        ]))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zComplexParamsData = z.object({
    body: z.optional(z.object({
        key: z.readonly(z.union([
            z.readonly(z.string().check(z.maxLength(64), z.regex(/^[a-zA-Z0-9_]*$/))),
            z.null()
        ])),
        name: z.union([
            z.string().check(z.maxLength(255)),
            z.null()
        ]),
        enabled: z._default(z.optional(z.boolean()), true),
        type: z.enum([
            'Monkey',
            'Horse',
            'Bird'
        ]),
        listOfModels: z.optional(z.union([
            z.array(zModelWithString),
            z.null()
        ])),
        listOfStrings: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        parameters: z.union([
            zModelWithString,
            zModelWithEnum,
            zModelWithArray,
            zModelWithDictionary
        ]),
        user: z.optional(z.readonly(z.object({
            id: z.optional(z.readonly(z.int())),
            name: z.optional(z.readonly(z.union([
                z.readonly(z.string()),
                z.null()
            ])))
        })))
    })),
    path: z.object({
        id: z.int(),
        'api-version': z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Success
 */
export const zComplexParamsResponse = zModelWithString;

export const zCallWithResultFromHeaderData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestErrorCodeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        status: z.int()
    })
});

export const zNonAsciiæøåÆøÅöôêÊ字符串Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        'nonAsciiParamæøåÆØÅöôêÊ': z.int()
    })
});

/**
 * Successful response
 */
export const zNonAsciiæøåÆøÅöôêÊ字符串Response = z.array(zNonAsciiStringæøåÆøÅöôêÊ字符串);

export const zPutWithFormUrlEncodedData = z.object({
    body: zArrayWithStringsWritable,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});