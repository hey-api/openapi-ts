// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * External ref to shared model (A)
 */
export const zExternalRefA = z.object({
    id: z.string(),
    name: z.optional(z.string())
});

export const zExternalRefB = zExternalRefA;

/**
 * Testing multiline comments in string: First line
 * Second line
 *
 * Fourth line
 */
export const zCommentWithBreaks = z.int();

/**
 * Testing backticks in string: `backticks` and ```multiple backticks``` should work
 */
export const zCommentWithBackticks = z.int();

/**
 * Testing backticks and quotes in string: `backticks`, 'quotes', "double quotes" and ```multiple backticks``` should work
 */
export const zCommentWithBackticksAndQuotes = z.int();

/**
 * Testing slashes in string: \backwards\\\ and /forwards/// should work
 */
export const zCommentWithSlashes = z.int();

/**
 * Testing expression placeholders in string: ${expression} should work
 */
export const zCommentWithExpressionPlaceholders = z.int();

/**
 * Testing quotes in string: 'single quote''' and "double quotes""" should work
 */
export const zCommentWithQuotes = z.int();

/**
 * Testing reserved characters in string: * inline * and ** inline ** should work
 */
export const zCommentWithReservedCharacters = z.int();

/**
 * This is a simple number
 */
export const zSimpleInteger = z.int();

/**
 * This is a simple boolean
 */
export const zSimpleBoolean = z.boolean();

/**
 * This is a simple string
 */
export const zSimpleString = z.string();

/**
 * A string with non-ascii (unicode) characters valid in typescript identifiers (æøåÆØÅöÔèÈ字符串)
 */
export const zNonAsciiStringæøåÆøÅöôêÊ字符串 = z.string();

/**
 * This is a simple file
 */
export const zSimpleFile = z.string();

/**
 * This is a model with one string property
 */
export const zModelWithString = z.object({
    prop: z.optional(z.string())
});

export const zSimpleReference = zModelWithString;

/**
 * This is a simple string
 */
export const zSimpleStringWithPattern = z.string().max(64).regex(/^[a-zA-Z0-9_]*$/);

/**
 * This is a simple enum with strings
 */
export const zEnumWithStrings = z.enum([
    'Success',
    'Warning',
    'Error',
    "'Single Quote'",
    '"Double Quotes"',
    'Non-ascii: øæåôöØÆÅÔÖ字符串'
]);

/**
 * This is a simple enum with numbers
 */
export const zEnumWithNumbers = z.unknown();

/**
 * Success=1,Warning=2,Error=3
 */
export const zEnumFromDescription = z.number();

/**
 * This is a simple enum with numbers
 */
export const zEnumWithExtensions = z.unknown();

/**
 * This is a simple array with numbers
 */
export const zArrayWithNumbers = z.array(z.int());

/**
 * This is a simple array with booleans
 */
export const zArrayWithBooleans = z.array(z.boolean());

/**
 * This is a simple array with strings
 */
export const zArrayWithStrings = z.array(z.string());

/**
 * This is a simple array with references
 */
export const zArrayWithReferences = z.array(zModelWithString);

/**
 * This is a simple array containing an array
 */
export const zArrayWithArray = z.array(z.array(zModelWithString));

/**
 * This is a simple array with properties
 */
export const zArrayWithProperties = z.array(z.object({
    foo: z.optional(z.string()),
    bar: z.optional(z.string())
}));

/**
 * This is a string dictionary
 */
export const zDictionaryWithString = z.record(z.string(), z.string());

/**
 * This is a string reference
 */
export const zDictionaryWithReference = z.record(z.string(), zModelWithString);

/**
 * This is a complex dictionary
 */
export const zDictionaryWithArray = z.record(z.string(), z.array(zModelWithString));

/**
 * This is a string dictionary
 */
export const zDictionaryWithDictionary = z.record(z.string(), z.record(z.string(), z.string()));

/**
 * This is a complex dictionary
 */
export const zDictionaryWithProperties = z.record(z.string(), z.object({
    foo: z.optional(z.string()),
    bar: z.optional(z.string())
}));

/**
 * This is a type-only model that defines Date as a string
 */
export const zDate = z.string();

/**
 * This is a model with one number property
 */
export const zModelWithInteger = z.object({
    prop: z.optional(z.int())
});

/**
 * This is a model with one boolean property
 */
export const zModelWithBoolean = z.object({
    prop: z.optional(z.boolean())
});

/**
 * This is a model with one string property
 */
export const zModelWithStringError = z.object({
    prop: z.optional(z.string())
});

/**
 * This is a model with one string property
 */
export const zModelWithNullableString = z.object({
    nullableProp: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    nullableRequiredProp: z.union([
        z.string(),
        z.null()
    ])
});

/**
 * This is a model with one enum
 */
export const zModelWithEnum = z.object({
    test: z.optional(z.enum([
        'Success',
        'Warning',
        'Error',
        'ØÆÅ字符串'
    ])),
    statusCode: z.optional(z.enum([
        '100',
        '200 FOO',
        '300 FOO_BAR',
        '400 foo-bar',
        '500 foo.bar',
        '600 foo&bar'
    ])),
    bool: z.optional(z.unknown())
});

/**
 * This is a model with one enum
 */
export const zModelWithEnumFromDescription = z.object({
    test: z.optional(z.int())
});

/**
 * This is a model with nested enums
 */
export const zModelWithNestedEnums = z.object({
    dictionaryWithEnum: z.optional(z.record(z.string(), z.enum([
        'Success',
        'Warning',
        'Error'
    ]))),
    dictionaryWithEnumFromDescription: z.optional(z.record(z.string(), z.int())),
    arrayWithEnum: z.optional(z.array(z.enum([
        'Success',
        'Warning',
        'Error'
    ]))),
    arrayWithDescription: z.optional(z.array(z.int()))
});

/**
 * This is a model with one nested property
 */
export const zModelWithProperties = z.object({
    required: z.string(),
    requiredAndReadOnly: z.string().readonly(),
    string: z.optional(z.string()),
    number: z.optional(z.number()),
    boolean: z.optional(z.boolean()),
    reference: z.optional(zModelWithString),
    'property with space': z.optional(z.string()),
    default: z.optional(z.string()),
    try: z.optional(z.string()),
    '@namespace.string': z.optional(z.string().readonly()),
    '@namespace.integer': z.optional(z.int().readonly())
});

/**
 * This is a model with one property containing a reference
 */
export const zModelWithReference = z.object({
    prop: z.optional(zModelWithProperties)
});

/**
 * This is a model with one property containing an array
 */
export const zModelWithArray = z.object({
    prop: z.optional(z.array(zModelWithString)),
    propWithFile: z.optional(z.array(z.string())),
    propWithNumber: z.optional(z.array(z.number()))
});

/**
 * This is a model with one property containing a dictionary
 */
export const zModelWithDictionary = z.object({
    prop: z.optional(z.record(z.string(), z.string()))
});

/**
 * This is a model with one property containing a circular reference
 */
export const zModelWithCircularReference = z.object({
    get prop(): z.ZodOptional {
        return z.optional(z.lazy((): any => {
            return zModelWithCircularReference;
        }));
    }
});

/**
 * This is a model with one nested property
 */
export const zModelWithNestedProperties = z.object({
    first: z.object({
        second: z.object({
            third: z.string().readonly()
        }).readonly()
    }).readonly()
});

/**
 * This is a model with duplicated properties
 */
export const zModelWithDuplicateProperties = z.object({
    prop: z.optional(zModelWithString)
});

/**
 * This is a model with ordered properties
 */
export const zModelWithOrderedProperties = z.object({
    zebra: z.optional(z.string()),
    apple: z.optional(z.string()),
    hawaii: z.optional(z.string())
});

/**
 * This is a model with duplicated imports
 */
export const zModelWithDuplicateImports = z.object({
    propA: z.optional(zModelWithString),
    propB: z.optional(zModelWithString),
    propC: z.optional(zModelWithString)
});

/**
 * This is a model that extends another model
 */
export const zModelThatExtends = zModelWithString.and(z.object({
    propExtendsA: z.optional(z.string()),
    propExtendsB: z.optional(zModelWithString)
}));

/**
 * This is a model that extends another model
 */
export const zModelThatExtendsExtends = zModelWithString.and(zModelThatExtends).and(z.object({
    propExtendsC: z.optional(z.string()),
    propExtendsD: z.optional(zModelWithString)
}));

export const zDefault = z.object({
    name: z.optional(z.string())
});

/**
 * This is a model that contains a some patterns
 */
export const zModelWithPattern = z.object({
    key: z.string().max(64).regex(/^[a-zA-Z0-9_]*$/),
    name: z.string().max(255),
    enabled: z.optional(z.boolean().readonly()),
    modified: z.optional(z.iso.datetime().readonly()),
    id: z.optional(z.string().regex(/^\d{2}-\d{3}-\d{4}$/)),
    text: z.optional(z.string().regex(/^\w+$/)),
    patternWithSingleQuotes: z.optional(z.string().regex(/^[a-zA-Z0-9']*$/)),
    patternWithNewline: z.optional(z.string().regex(/aaa\nbbb/)),
    patternWithBacktick: z.optional(z.string().regex(/aaa`bbb/))
});

export const zParameterActivityParams = z.object({
    description: z.optional(z.string()),
    graduate_id: z.optional(z.int()),
    organization_id: z.optional(z.int()),
    parent_activity: z.optional(z.int()),
    post_id: z.optional(z.int())
});

export const zResponsePostActivityResponse = z.object({
    description: z.optional(z.string()),
    graduate_id: z.optional(z.int()),
    organization_id: z.optional(z.int()),
    parent_activity_id: z.optional(z.int()),
    post_id: z.optional(z.int())
});

export const zFailureFailure = z.object({
    error: z.optional(z.string()),
    message: z.optional(z.string()),
    reference_code: z.optional(z.string())
});

/**
 * This is a model with one nested property
 */
export const zModelWithPropertiesWritable = z.object({
    required: z.string(),
    string: z.optional(z.string()),
    number: z.optional(z.number()),
    boolean: z.optional(z.boolean()),
    reference: z.optional(zModelWithString),
    'property with space': z.optional(z.string()),
    default: z.optional(z.string()),
    try: z.optional(z.string())
});

/**
 * This is a model that contains a some patterns
 */
export const zModelWithPatternWritable = z.object({
    key: z.string().max(64).regex(/^[a-zA-Z0-9_]*$/),
    name: z.string().max(255),
    id: z.optional(z.string().regex(/^\d{2}-\d{3}-\d{4}$/)),
    text: z.optional(z.string().regex(/^\w+$/)),
    patternWithSingleQuotes: z.optional(z.string().regex(/^[a-zA-Z0-9']*$/)),
    patternWithNewline: z.optional(z.string().regex(/aaa\nbbb/)),
    patternWithBacktick: z.optional(z.string().regex(/aaa`bbb/))
});

export const zServiceWithEmptyTagData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPatchApiVbyApiVersionNoTagData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zFooWowData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDeleteCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zHeadCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zOptionsCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPatchCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPostCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zPutCallWithoutParametersAndResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithDescriptionsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameterWithBreaks: z.optional(z.string()),
        parameterWithBackticks: z.optional(z.string()),
        parameterWithSlashes: z.optional(z.string()),
        parameterWithExpressionPlaceholders: z.optional(z.string()),
        parameterWithQuotes: z.optional(z.string()),
        parameterWithReservedCharacters: z.optional(z.string())
    }))
});

export const zCallWithParametersData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        parameterPath: z.string(),
        'api-version': z.string()
    }),
    query: z.object({
        parameterQuery: z.string()
    }),
    headers: z.object({
        parameterHeader: z.string()
    })
});

export const zCallWithWeirdParameterNamesData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        'parameter.path.1': z.optional(z.string()),
        'parameter-path-2': z.optional(z.string()),
        'PARAMETER-PATH-3': z.optional(z.string()),
        'api-version': z.string()
    }),
    query: z.object({
        default: z.optional(z.string()),
        'parameter-query': z.string()
    }),
    headers: z.object({
        'parameter.header': z.string()
    })
});

export const zCallWithDefaultParametersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterString: z.string().default('Hello World!'),
        parameterNumber: z.number().default(123),
        parameterBoolean: z.boolean().default(true),
        parameterEnum: z.enum([
            'Success',
            'Warning',
            'Error'
        ]),
        parameterModel: z.object({
            prop: z.optional(z.string())
        }).default({
            prop: 'Hello World!'
        })
    })
});

export const zCallWithDefaultOptionalParametersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        parameterString: z.optional(z.string()).default('Hello World!'),
        parameterNumber: z.optional(z.number()).default(123),
        parameterBoolean: z.optional(z.boolean()).default(true),
        parameterEnum: z.optional(z.enum([
            'Success',
            'Warning',
            'Error'
        ]))
    }))
});

export const zCallToTestOrderOfParamsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterOptionalStringWithDefault: z.optional(z.string()).default('Hello World!'),
        parameterOptionalStringWithEmptyDefault: z.optional(z.string()).default(''),
        parameterOptionalStringWithNoDefault: z.optional(z.string()),
        parameterStringWithDefault: z.string().default('Hello World!'),
        parameterStringWithEmptyDefault: z.string().default(''),
        parameterStringWithNoDefault: z.string(),
        parameterStringNullableWithNoDefault: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        parameterStringNullableWithDefault: z.optional(z.union([
            z.string(),
            z.null()
        ])).default(null)
    })
});

export const zDuplicateNameData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDuplicateName2Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDuplicateName3Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDuplicateName4Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithNoContentResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponseAndNoContentResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponseAndNoContentResponseResponse = z.union([
    z.number(),
    z.unknown()
]);

export const zDummyAData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zDummyBData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponseData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Message for default response
 */
export const zCallWithResponseResponse = zModelWithString;

export const zCallWithDuplicateResponsesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Message for 201 response
 */
export const zCallWithDuplicateResponsesResponse = zModelWithString;

export const zCallWithResponsesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zCallWithResponsesResponse = z.union([
    z.object({
        '@namespace.string': z.optional(z.string().readonly()),
        '@namespace.integer': z.optional(z.int().readonly()),
        value: z.optional(z.array(zModelWithString).readonly())
    }),
    zModelThatExtends,
    zModelThatExtendsExtends
]);

export const zCollectionFormatData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterArrayCSV: z.array(z.string()),
        parameterArraySSV: z.array(z.string()),
        parameterArrayTSV: z.array(z.string()),
        parameterArrayPipes: z.array(z.string()),
        parameterArrayMulti: z.array(z.string())
    })
});

export const zTypesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.object({
        id: z.optional(z.int())
    })),
    query: z.object({
        parameterNumber: z.number().default(123),
        parameterString: z.string().default('default'),
        parameterBoolean: z.boolean().default(true),
        parameterArray: z.array(z.string()),
        parameterDictionary: z.record(z.string(), z.unknown()),
        parameterEnum: z.enum([
            'Success',
            'Warning',
            'Error'
        ])
    })
});

export const zTypesResponse = z.union([
    z.number(),
    z.string(),
    z.boolean(),
    z.record(z.string(), z.unknown())
]);

export const zComplexTypesData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        parameterObject: z.object({
            first: z.optional(z.object({
                second: z.optional(z.object({
                    third: z.optional(z.string())
                }))
            }))
        }),
        parameterReference: z.object({
            prop: z.optional(z.string())
        })
    })
});

/**
 * Successful response
 */
export const zComplexTypesResponse = z.array(zModelWithString);

export const zCallWithResultFromHeaderData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zTestErrorCodeData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        status: z.string()
    })
});

export const zNonAsciiæøåÆøÅöôêÊ字符串Data = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.object({
        'nonAsciiParamæøåÆØÅöôêÊ': z.int()
    })
});

/**
 * Successful response
 */
export const zNonAsciiæøåÆøÅöôêÊ字符串Response = zNonAsciiStringæøåÆøÅöôêÊ字符串;

export const zPostApiVbyApiVersionBodyData = z.object({
    body: zParameterActivityParams,
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * OK
 */
export const zPostApiVbyApiVersionBodyResponse = zResponsePostActivityResponse;