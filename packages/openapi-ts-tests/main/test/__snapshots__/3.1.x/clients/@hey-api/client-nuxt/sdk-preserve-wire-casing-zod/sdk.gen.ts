// This file is auto-generated by @hey-api/openapi-ts

import { type Options as ClientOptions, type Composable, type Client, type TDataShape, formDataBodySerializer, urlSearchParamsBodySerializer } from './client';
import type { ExportData, PatchApiVbyApiVersionNoTagData, ImportResponse, ImportData, FooWowData, ApiVVersionODataControllerCountResponse, ApiVVersionODataControllerCountData, GetApiVbyApiVersionSimpleOperationResponse, GetApiVbyApiVersionSimpleOperationData, GetApiVbyApiVersionSimpleOperationError, DeleteCallWithoutParametersAndResponseData, GetCallWithoutParametersAndResponseData, HeadCallWithoutParametersAndResponseData, OptionsCallWithoutParametersAndResponseData, PatchCallWithoutParametersAndResponseData, PostCallWithoutParametersAndResponseData, PutCallWithoutParametersAndResponseData, DeleteFooData3 as DeleteFooData, CallWithDescriptionsData, DeprecatedCallData, CallWithParametersData, CallWithWeirdParameterNamesData, GetCallWithOptionalParamData, PostCallWithOptionalParamResponse, PostCallWithOptionalParamData, PostApiVbyApiVersionRequestBodyData, PostApiVbyApiVersionFormDataData, CallWithDefaultParametersData, CallWithDefaultOptionalParametersData, CallToTestOrderOfParamsData, DuplicateNameData, DuplicateName2Data, DuplicateName3Data, DuplicateName4Data, CallWithNoContentResponseResponse, CallWithNoContentResponseData, CallWithResponseAndNoContentResponseResponse, CallWithResponseAndNoContentResponseData, DummyAResponse, DummyAData, DummyBResponse, DummyBData, CallWithResponseResponse, CallWithResponseData, CallWithDuplicateResponsesResponse, CallWithDuplicateResponsesData, CallWithDuplicateResponsesError, CallWithResponsesResponse, CallWithResponsesData, CallWithResponsesError, CollectionFormatData, TypesResponse, TypesData, UploadFileResponse, UploadFileData, FileResponseResponse, FileResponseData, ComplexTypesResponse, ComplexTypesData, MultipartResponseResponse, MultipartResponseData, MultipartRequestData, ComplexParamsResponse, ComplexParamsData, CallWithResultFromHeaderData, TestErrorCodeData, NonAsciiæøåÆøÅöôêÊ字符串Response, NonAsciiæøåÆøÅöôêÊ字符串Data, PutWithFormUrlEncodedData } from './types.gen';
import { zExportData, zPatchApiVbyApiVersionNoTagData, zImportData, zImportResponse, zFooWowData, zApiVVersionODataControllerCountData, zApiVVersionODataControllerCountResponse, zGetApiVbyApiVersionSimpleOperationData, zGetApiVbyApiVersionSimpleOperationResponse, zDeleteCallWithoutParametersAndResponseData, zGetCallWithoutParametersAndResponseData, zHeadCallWithoutParametersAndResponseData, zOptionsCallWithoutParametersAndResponseData, zPatchCallWithoutParametersAndResponseData, zPostCallWithoutParametersAndResponseData, zPutCallWithoutParametersAndResponseData, zDeleteFooData3 as zDeleteFooData, zCallWithDescriptionsData, zDeprecatedCallData, zCallWithParametersData, zCallWithWeirdParameterNamesData, zGetCallWithOptionalParamData, zPostCallWithOptionalParamData, zPostCallWithOptionalParamResponse, zPostApiVbyApiVersionRequestBodyData, zPostApiVbyApiVersionFormDataData, zCallWithDefaultParametersData, zCallWithDefaultOptionalParametersData, zCallToTestOrderOfParamsData, zDuplicateNameData, zDuplicateName2Data, zDuplicateName3Data, zDuplicateName4Data, zCallWithNoContentResponseData, zCallWithNoContentResponseResponse, zCallWithResponseAndNoContentResponseData, zCallWithResponseAndNoContentResponseResponse, zDummyAData, zDummyAResponse, zDummyBData, zDummyBResponse, zCallWithResponseData, zCallWithResponseResponse, zCallWithDuplicateResponsesData, zCallWithDuplicateResponsesResponse, zCallWithResponsesData, zCallWithResponsesResponse, zCollectionFormatData, zTypesData, zTypesResponse, zUploadFileData, zUploadFileResponse, zFileResponseData, zFileResponseResponse, zComplexTypesData, zComplexTypesResponse, zMultipartResponseData, zMultipartResponseResponse, zMultipartRequestData, zComplexParamsData, zComplexParamsResponse, zCallWithResultFromHeaderData, zTestErrorCodeData, zNonAsciiæøåÆøÅöôêÊ字符串Data, zNonAsciiæøåÆøÅöôêÊ字符串Response, zPutWithFormUrlEncodedData } from './zod.gen';
import { client } from './client.gen';

export type Options<TComposable extends Composable = '$fetch', TData extends TDataShape = TDataShape, ResT = unknown, DefaultT = undefined> = ClientOptions<TComposable, TData, ResT, DefaultT> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

export const export_ = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, ExportData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zExportData.parseAsync(data);
        },
        url: '/api/v{api-version}/no+tag',
        ...options
    });
};

export const patchApiVbyApiVersionNoTag = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PatchApiVbyApiVersionNoTagData, unknown, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zPatchApiVbyApiVersionNoTagData.parseAsync(data);
        },
        url: '/api/v{api-version}/no+tag',
        ...options
    });
};

export const import_ = <TComposable extends Composable = '$fetch', DefaultT extends ImportResponse = ImportResponse>(options: Options<TComposable, ImportData, ImportResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, ImportResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zImportData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zImportResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/no+tag',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

export const fooWow = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, FooWowData, unknown, DefaultT>) => {
    return (options.client ?? client).put<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zFooWowData.parseAsync(data);
        },
        url: '/api/v{api-version}/no+tag',
        ...options
    });
};

export const apiVVersionODataControllerCount = <TComposable extends Composable = '$fetch', DefaultT extends ApiVVersionODataControllerCountResponse = ApiVVersionODataControllerCountResponse>(options: Options<TComposable, ApiVVersionODataControllerCountData, ApiVVersionODataControllerCountResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ApiVVersionODataControllerCountResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zApiVVersionODataControllerCountData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zApiVVersionODataControllerCountResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/simple/$count',
        ...options
    });
};

export const getApiVbyApiVersionSimpleOperation = <TComposable extends Composable = '$fetch', DefaultT extends GetApiVbyApiVersionSimpleOperationResponse = GetApiVbyApiVersionSimpleOperationResponse>(options: Options<TComposable, GetApiVbyApiVersionSimpleOperationData, GetApiVbyApiVersionSimpleOperationResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, GetApiVbyApiVersionSimpleOperationResponse | DefaultT, GetApiVbyApiVersionSimpleOperationError, DefaultT>({
        requestKeyMapper: options => {
            if (options.path) {
                if ('fooParam' in options.path) {
                    options.path.foo_param = options.path.fooParam;
                    delete options.path.fooParam;
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetApiVbyApiVersionSimpleOperationData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetApiVbyApiVersionSimpleOperationResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/simple:operation',
        ...options
    });
};

export const deleteCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDeleteCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const getCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, GetCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zGetCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const headCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, HeadCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).head<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zHeadCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const optionsCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, OptionsCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).options<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zOptionsCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const patchCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PatchCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).patch<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zPatchCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const postCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PostCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zPostCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const putCallWithoutParametersAndResponse = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PutCallWithoutParametersAndResponseData, unknown, DefaultT>) => {
    return (options.client ?? client).put<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zPutCallWithoutParametersAndResponseData.parseAsync(data);
        },
        url: '/api/v{api-version}/simple',
        ...options
    });
};

export const deleteFoo = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeleteFooData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.path) {
                if ('fooParam' in options.path) {
                    options.path.foo_param = options.path.fooParam;
                    delete options.path.fooParam;
                }
                if ('barParam' in options.path) {
                    options.path.BarParam = options.path.barParam;
                    delete options.path.barParam;
                }
            }
            if (options.headers) {
                {
                    if ("get" in options.headers && "set" in options.headers) {
                        const _val = options.headers.get("xFooBar");
                        if (_val !== null) {
                            const _setRet = options.headers.set("x-Foo-Bar", _val as any);
                            if (typeof _setRet !== "undefined") {
                                options.headers = _setRet as any;
                            }
                            if ("delete" in options.headers) {
                                const _delRet = options.headers.delete("xFooBar");
                                if (typeof _delRet !== "undefined") {
                                    options.headers = _delRet as any;
                                }
                            }
                        }
                    }
                    else if ('xFooBar' in options.headers) {
                        options.headers['x-Foo-Bar'] = options.headers.xFooBar;
                        delete options.headers.xFooBar;
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zDeleteFooData.parseAsync(data);
        },
        url: '/api/v{api-version}/foo/{foo_param}/bar/{BarParam}',
        ...options
    });
};

export const callWithDescriptions = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallWithDescriptionsData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithDescriptionsData.parseAsync(data);
        },
        url: '/api/v{api-version}/descriptions',
        ...options
    });
};

/**
 * @deprecated
 */
export const deprecatedCall = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DeprecatedCallData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDeprecatedCallData.parseAsync(data);
        },
        url: '/api/v{api-version}/parameters/deprecated',
        ...options
    });
};

export const callWithParameters = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallWithParametersData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.path) {
                if ('apiVersion' in options.path) {
                    options.path['api-version'] = options.path.apiVersion;
                    delete options.path.apiVersion;
                }
            }
            if (options.query) {
                if ('fooRefEnum' in options.query) {
                    options.query.foo_ref_enum = options.query.fooRefEnum;
                    delete options.query.fooRefEnum;
                }
                if ('fooAllOfEnum' in options.query) {
                    options.query.foo_all_of_enum = options.query.fooAllOfEnum;
                    delete options.query.fooAllOfEnum;
                }
            }
        },
        requestValidator: async (data) => {
            return await zCallWithParametersData.parseAsync(data);
        },
        url: '/api/v{api-version}/parameters/{parameterPath}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

export const callWithWeirdParameterNames = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallWithWeirdParameterNamesData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.path) {
                if ('parameterPath1' in options.path) {
                    options.path['parameter.path.1'] = options.path.parameterPath1;
                    delete options.path.parameterPath1;
                }
                if ('parameterPath2' in options.path) {
                    options.path['parameter-path-2'] = options.path.parameterPath2;
                    delete options.path.parameterPath2;
                }
                if ('parameterPath3' in options.path) {
                    options.path['PARAMETER-PATH-3'] = options.path.parameterPath3;
                    delete options.path.parameterPath3;
                }
                if ('apiVersion' in options.path) {
                    options.path['api-version'] = options.path.apiVersion;
                    delete options.path.apiVersion;
                }
            }
            if (options.query) {
                if ('parameterQuery' in options.query) {
                    options.query['parameter-query'] = options.query.parameterQuery;
                    delete options.query.parameterQuery;
                }
            }
            if (options.headers) {
                {
                    if ("get" in options.headers && "set" in options.headers) {
                        const _val = options.headers.get("parameterHeader");
                        if (_val !== null) {
                            const _setRet = options.headers.set("parameter.header", _val as any);
                            if (typeof _setRet !== "undefined") {
                                options.headers = _setRet as any;
                            }
                            if ("delete" in options.headers) {
                                const _delRet = options.headers.delete("parameterHeader");
                                if (typeof _delRet !== "undefined") {
                                    options.headers = _delRet as any;
                                }
                            }
                        }
                    }
                    else if ('parameterHeader' in options.headers) {
                        options.headers['parameter.header'] = options.headers.parameterHeader;
                        delete options.headers.parameterHeader;
                    }
                }
            }
            if (options.cookie) {
                if ('parameterCookie' in options.cookie) {
                    options.cookie['PARAMETER-COOKIE'] = options.cookie.parameterCookie;
                    delete options.cookie.parameterCookie;
                }
            }
        },
        requestValidator: async (data) => {
            return await zCallWithWeirdParameterNamesData.parseAsync(data);
        },
        url: '/api/v{api-version}/parameters/{parameter.path.1}/{parameter-path-2}/{PARAMETER-PATH-3}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

export const getCallWithOptionalParam = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, GetCallWithOptionalParamData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zGetCallWithOptionalParamData.parseAsync(data);
        },
        url: '/api/v{api-version}/parameters',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

export const postCallWithOptionalParam = <TComposable extends Composable = '$fetch', DefaultT extends PostCallWithOptionalParamResponse = PostCallWithOptionalParamResponse>(options: Options<TComposable, PostCallWithOptionalParamData, PostCallWithOptionalParamResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, PostCallWithOptionalParamResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zPostCallWithOptionalParamData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostCallWithOptionalParamResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/parameters',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

export const postApiVbyApiVersionRequestBody = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PostApiVbyApiVersionRequestBodyData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zPostApiVbyApiVersionRequestBodyData.parseAsync(data);
        },
        url: '/api/v{api-version}/requestBody',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

export const postApiVbyApiVersionFormData = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PostApiVbyApiVersionFormDataData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        ...formDataBodySerializer,
        requestValidator: async (data) => {
            return await zPostApiVbyApiVersionFormDataData.parseAsync(data);
        },
        url: '/api/v{api-version}/formData',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

export const callWithDefaultParameters = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallWithDefaultParametersData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithDefaultParametersData.parseAsync(data);
        },
        url: '/api/v{api-version}/defaults',
        ...options
    });
};

export const callWithDefaultOptionalParameters = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallWithDefaultOptionalParametersData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithDefaultOptionalParametersData.parseAsync(data);
        },
        url: '/api/v{api-version}/defaults',
        ...options
    });
};

export const callToTestOrderOfParams = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallToTestOrderOfParamsData, unknown, DefaultT>) => {
    return (options.client ?? client).put<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallToTestOrderOfParamsData.parseAsync(data);
        },
        url: '/api/v{api-version}/defaults',
        ...options
    });
};

export const duplicateName = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DuplicateNameData, unknown, DefaultT>) => {
    return (options.client ?? client).delete<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDuplicateNameData.parseAsync(data);
        },
        url: '/api/v{api-version}/duplicate',
        ...options
    });
};

export const duplicateName2 = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DuplicateName2Data, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDuplicateName2Data.parseAsync(data);
        },
        url: '/api/v{api-version}/duplicate',
        ...options
    });
};

export const duplicateName3 = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DuplicateName3Data, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDuplicateName3Data.parseAsync(data);
        },
        url: '/api/v{api-version}/duplicate',
        ...options
    });
};

export const duplicateName4 = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, DuplicateName4Data, unknown, DefaultT>) => {
    return (options.client ?? client).put<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDuplicateName4Data.parseAsync(data);
        },
        url: '/api/v{api-version}/duplicate',
        ...options
    });
};

export const callWithNoContentResponse = <TComposable extends Composable = '$fetch', DefaultT extends CallWithNoContentResponseResponse = CallWithNoContentResponseResponse>(options: Options<TComposable, CallWithNoContentResponseData, CallWithNoContentResponseResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, CallWithNoContentResponseResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithNoContentResponseData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCallWithNoContentResponseResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/no-content',
        ...options
    });
};

export const callWithResponseAndNoContentResponse = <TComposable extends Composable = '$fetch', DefaultT extends CallWithResponseAndNoContentResponseResponse = CallWithResponseAndNoContentResponseResponse>(options: Options<TComposable, CallWithResponseAndNoContentResponseData, CallWithResponseAndNoContentResponseResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, CallWithResponseAndNoContentResponseResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithResponseAndNoContentResponseData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCallWithResponseAndNoContentResponseResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/multiple-tags/response-and-no-content',
        ...options
    });
};

export const dummyA = <TComposable extends Composable = '$fetch', DefaultT extends DummyAResponse = DummyAResponse>(options: Options<TComposable, DummyAData, DummyAResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, DummyAResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDummyAData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zDummyAResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/multiple-tags/a',
        ...options
    });
};

export const dummyB = <TComposable extends Composable = '$fetch', DefaultT extends DummyBResponse = DummyBResponse>(options: Options<TComposable, DummyBData, DummyBResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, DummyBResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zDummyBData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zDummyBResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/multiple-tags/b',
        ...options
    });
};

export const callWithResponse = <TComposable extends Composable = '$fetch', DefaultT extends CallWithResponseResponse = CallWithResponseResponse>(options: Options<TComposable, CallWithResponseData, CallWithResponseResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, CallWithResponseResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithResponseData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCallWithResponseResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/response',
        ...options
    });
};

export const callWithDuplicateResponses = <TComposable extends Composable = '$fetch', DefaultT extends CallWithDuplicateResponsesResponse = CallWithDuplicateResponsesResponse>(options: Options<TComposable, CallWithDuplicateResponsesData, CallWithDuplicateResponsesResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, CallWithDuplicateResponsesResponse | DefaultT, CallWithDuplicateResponsesError, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithDuplicateResponsesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCallWithDuplicateResponsesResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/response',
        ...options
    });
};

export const callWithResponses = <TComposable extends Composable = '$fetch', DefaultT extends CallWithResponsesResponse = CallWithResponsesResponse>(options: Options<TComposable, CallWithResponsesData, CallWithResponsesResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, CallWithResponsesResponse | DefaultT, CallWithResponsesError, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithResponsesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zCallWithResponsesResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/response',
        ...options
    });
};

export const collectionFormat = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CollectionFormatData, unknown, DefaultT>) => {
    return (options.client ?? client).get<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.query) {
                if ('parameterArrayCsv' in options.query) {
                    options.query.parameterArrayCSV = options.query.parameterArrayCsv;
                    delete options.query.parameterArrayCsv;
                }
                if ('parameterArraySsv' in options.query) {
                    options.query.parameterArraySSV = options.query.parameterArraySsv;
                    delete options.query.parameterArraySsv;
                }
                if ('parameterArrayTsv' in options.query) {
                    options.query.parameterArrayTSV = options.query.parameterArrayTsv;
                    delete options.query.parameterArrayTsv;
                }
            }
        },
        requestValidator: async (data) => {
            return await zCollectionFormatData.parseAsync(data);
        },
        url: '/api/v{api-version}/collectionFormat',
        ...options
    });
};

export const types = <TComposable extends Composable = '$fetch', DefaultT extends TypesResponse = TypesResponse>(options: Options<TComposable, TypesData, TypesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, TypesResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zTypesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zTypesResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/types',
        ...options
    });
};

export const uploadFile = <TComposable extends Composable = '$fetch', DefaultT extends UploadFileResponse = UploadFileResponse>(options: Options<TComposable, UploadFileData, UploadFileResponse, DefaultT>) => {
    return (options.client ?? client).post<TComposable, UploadFileResponse | DefaultT, unknown, DefaultT>({
        ...urlSearchParamsBodySerializer,
        requestKeyMapper: options => {
            if (options.path) {
                if ('apiVersion' in options.path) {
                    options.path['api-version'] = options.path.apiVersion;
                    delete options.path.apiVersion;
                }
            }
        },
        requestValidator: async (data) => {
            return await zUploadFileData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zUploadFileResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/upload',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options.headers
        }
    });
};

export const fileResponse = <TComposable extends Composable = '$fetch', DefaultT extends FileResponseResponse = FileResponseResponse>(options: Options<TComposable, FileResponseData, FileResponseResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, FileResponseResponse | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.path) {
                if ('apiVersion' in options.path) {
                    options.path['api-version'] = options.path.apiVersion;
                    delete options.path.apiVersion;
                }
            }
        },
        requestValidator: async (data) => {
            return await zFileResponseData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zFileResponseResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/file/{id}',
        ...options
    });
};

export const complexTypes = <TComposable extends Composable = '$fetch', DefaultT extends ComplexTypesResponse = ComplexTypesResponse>(options: Options<TComposable, ComplexTypesData, ComplexTypesResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, ComplexTypesResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zComplexTypesData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zComplexTypesResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/complex',
        ...options
    });
};

export const multipartResponse = <TComposable extends Composable = '$fetch', DefaultT extends MultipartResponseResponse = MultipartResponseResponse>(options: Options<TComposable, MultipartResponseData, MultipartResponseResponse, DefaultT>) => {
    return (options.client ?? client).get<TComposable, MultipartResponseResponse | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zMultipartResponseData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zMultipartResponseResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/multipart',
        ...options
    });
};

export const multipartRequest = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, MultipartRequestData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        ...formDataBodySerializer,
        requestValidator: async (data) => {
            return await zMultipartRequestData.parseAsync(data);
        },
        url: '/api/v{api-version}/multipart',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

export const complexParams = <TComposable extends Composable = '$fetch', DefaultT extends ComplexParamsResponse = ComplexParamsResponse>(options: Options<TComposable, ComplexParamsData, ComplexParamsResponse, DefaultT>) => {
    return (options.client ?? client).put<TComposable, ComplexParamsResponse | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.path) {
                if ('apiVersion' in options.path) {
                    options.path['api-version'] = options.path.apiVersion;
                    delete options.path.apiVersion;
                }
            }
            if (options.body) {
                if ('parameters' in options.body && (typeof options.body.parameters === "object" && options.body.parameters !== null))
                    if ('foo_bar-enum' in options.body.parameters)
                        if ('fooBarEnum' in options.body.parameters['foo_bar-enum']) {
                            options.body.parameters['foo_bar-enum']['foo_bar-enum'] = options.body.parameters['foo_bar-enum'].fooBarEnum;
                            delete options.body.parameters['foo_bar-enum'].fooBarEnum;
                        }
            }
        },
        requestValidator: async (data) => {
            return await zComplexParamsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zComplexParamsResponse.parseAsync(data);
        },
        url: '/api/v{api-version}/complex/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options.headers
        }
    });
};

export const callWithResultFromHeader = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, CallWithResultFromHeaderData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zCallWithResultFromHeaderData.parseAsync(data);
        },
        url: '/api/v{api-version}/header',
        ...options
    });
};

export const testErrorCode = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, TestErrorCodeData, unknown, DefaultT>) => {
    return (options.client ?? client).post<TComposable, unknown | DefaultT, unknown, DefaultT>({
        requestValidator: async (data) => {
            return await zTestErrorCodeData.parseAsync(data);
        },
        url: '/api/v{api-version}/error',
        ...options
    });
};

export const nonAsciiæøåÆøÅöôêÊ字符串 = <TComposable extends Composable = '$fetch', DefaultT extends NonAsciiæøåÆøÅöôêÊ字符串Response = NonAsciiæøåÆøÅöôêÊ字符串Response>(options: Options<TComposable, NonAsciiæøåÆøÅöôêÊ字符串Data, NonAsciiæøåÆøÅöôêÊ字符串Response, DefaultT>) => {
    return (options.client ?? client).post<TComposable, NonAsciiæøåÆøÅöôêÊ字符串Response | DefaultT, unknown, DefaultT>({
        requestKeyMapper: options => {
            if (options.query) {
                if ('nonAsciiParamæøåÆøÅöôêÊ' in options.query) {
                    options.query.nonAsciiParamæøåÆØÅöôêÊ = options.query.nonAsciiParamæøåÆøÅöôêÊ;
                    delete options.query.nonAsciiParamæøåÆøÅöôêÊ;
                }
            }
        },
        requestValidator: async (data) => {
            return await zNonAsciiæøåÆøÅöôêÊ字符串Data.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zNonAsciiæøåÆøÅöôêÊ字符串Response.parseAsync(data);
        },
        url: '/api/v{api-version}/non-ascii-æøåÆØÅöôêÊ字符串',
        ...options
    });
};

/**
 * Login User
 */
export const putWithFormUrlEncoded = <TComposable extends Composable = '$fetch', DefaultT = undefined>(options: Options<TComposable, PutWithFormUrlEncodedData, unknown, DefaultT>) => {
    return (options.client ?? client).put<TComposable, unknown | DefaultT, unknown, DefaultT>({
        ...urlSearchParamsBodySerializer,
        requestValidator: async (data) => {
            return await zPutWithFormUrlEncodedData.parseAsync(data);
        },
        url: '/api/v{api-version}/non-ascii-æøåÆØÅöôêÊ字符串',
        ...options,
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...options.headers
        }
    });
};
